# Source-Type-Specific Extraction — Walkthrough

## Problem Solved
The ingestion pipeline used **one generic LLM prompt** for all 86 sources, extracting wrong data:
- Developers (DAMAC, Emaar) → bedroom counts & property prices instead of finish specs
- Suppliers (Graniti) → product names but **null prices**
- `CATEGORY_MAP` routed everything to `"other"`

## Changes Made

### 1. Schema — 5 New Columns on `evidence_records`
`finishLevel` · `designStyle` · `brandsMentioned` · `materialSpec` · `intelligenceType`

All nullable — zero breaking changes.

```diff:schema.ts
import {
  int,
  mysqlEnum,
  mysqlTable,
  text,
  timestamp,
  varchar,
  decimal,
  boolean,
  json,
} from "drizzle-orm/mysql-core";

// ─── Users ───────────────────────────────────────────────────────────────────
export const users = mysqlTable("users", {
  id: int("id").autoincrement().primaryKey(),
  openId: varchar("openId", { length: 64 }).notNull().unique(),
  password: varchar("password", { length: 255 }),
  name: text("name"),
  email: varchar("email", { length: 320 }),
  loginMethod: varchar("loginMethod", { length: 64 }),
  role: mysqlEnum("role", ["user", "admin"]).default("user").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  lastSignedIn: timestamp("lastSignedIn").defaultNow().notNull(),
  orgId: int("orgId"), // added in V7 for backward compat later to be notNull
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;

// ─── Organizations (V7 - Multi-tenancy) ─────────────────────────────────────────────────────────
export const organizations = mysqlTable("organizations", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  slug: varchar("slug", { length: 255 }).notNull().unique(),
  domain: varchar("domain", { length: 255 }),
  plan: mysqlEnum("plan", ["free", "pro", "enterprise"]).default("free").notNull(),
  stripeCustomerId: varchar("stripeCustomerId", { length: 255 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Organization = typeof organizations.$inferSelect;
export type InsertOrganization = typeof organizations.$inferInsert;

export const organizationMembers = mysqlTable("organization_members", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId").notNull(),
  userId: int("userId").notNull(),
  role: mysqlEnum("role", ["admin", "member", "viewer"]).default("member").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type OrganizationMember = typeof organizationMembers.$inferSelect;
export type InsertOrganizationMember = typeof organizationMembers.$inferInsert;

export const organizationInvites = mysqlTable("organization_invites", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId").notNull(),
  email: varchar("email", { length: 320 }).notNull(),
  role: mysqlEnum("role", ["admin", "member", "viewer"]).default("member").notNull(),
  token: varchar("token", { length: 255 }).notNull().unique(),
  expiresAt: timestamp("expiresAt").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type OrganizationInvite = typeof organizationInvites.$inferSelect;
export type InsertOrganizationInvite = typeof organizationInvites.$inferInsert;


// ─── Model Versions ─────────────────────────────────────────────────────────
export const modelVersions = mysqlTable("model_versions", {
  id: int("id").autoincrement().primaryKey(),
  versionTag: varchar("versionTag", { length: 32 }).notNull().unique(),
  dimensionWeights: json("dimensionWeights").notNull(),
  variableWeights: json("variableWeights").notNull(),
  penaltyConfig: json("penaltyConfig").notNull(),
  isActive: boolean("isActive").default(false).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
  notes: text("notes"),
});

export type ModelVersion = typeof modelVersions.$inferSelect;
export type InsertModelVersion = typeof modelVersions.$inferInsert;

// ─── Benchmark Versions (V2) ───────────────────────────────────────────────
export const benchmarkVersions = mysqlTable("benchmark_versions", {
  id: int("id").autoincrement().primaryKey(),
  versionTag: varchar("versionTag", { length: 64 }).notNull().unique(),
  description: text("description"),
  status: mysqlEnum("status", ["draft", "published", "archived"]).default("draft").notNull(),
  publishedAt: timestamp("publishedAt"),
  publishedBy: int("publishedBy"),
  recordCount: int("recordCount").default(0),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
});

export type BenchmarkVersion = typeof benchmarkVersions.$inferSelect;
export type InsertBenchmarkVersion = typeof benchmarkVersions.$inferInsert;

// ─── Benchmark Categories (V2) ─────────────────────────────────────────────
export const benchmarkCategories = mysqlTable("benchmark_categories", {
  id: int("id").autoincrement().primaryKey(),
  category: mysqlEnum("category", [
    "materials",
    "finishes",
    "ffe",
    "procurement",
    "cost_bands",
    "tier_definitions",
    "style_families",
    "brand_archetypes",
    "risk_factors",
    "lead_times",
  ]).notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  market: varchar("market", { length: 64 }).default("UAE").notNull(),
  submarket: varchar("submarket", { length: 64 }).default("Dubai"),
  projectClass: mysqlEnum("projectClass", ["mid", "upper", "luxury", "ultra_luxury"]).notNull(),
  validFrom: timestamp("validFrom"),
  validTo: timestamp("validTo"),
  confidenceLevel: mysqlEnum("confidenceLevel", ["high", "medium", "low"]).default("medium"),
  sourceType: mysqlEnum("sourceType", ["manual", "admin", "imported", "curated"]).default("admin"),
  benchmarkVersionId: int("benchmarkVersionId"),
  data: json("data").notNull(),
  versionTag: varchar("versionTag", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  createdBy: int("createdBy"),
});

export type BenchmarkCategory = typeof benchmarkCategories.$inferSelect;
export type InsertBenchmarkCategory = typeof benchmarkCategories.$inferInsert;

// ─── Projects ────────────────────────────────────────────────────────────────
export const projects = mysqlTable("projects", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull(),
  orgId: int("orgId"),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  status: mysqlEnum("status", [
    "draft",
    "ready",
    "processing",
    "evaluated",
    "locked",
  ])
    .default("draft")
    .notNull(),

  // Approval gate (V2.8)
  approvalState: mysqlEnum("approvalState", [
    "draft",
    "review",
    "approved_rfq",
    "approved_marketing",
  ]).default("draft"),

  // Context variables
  ctx01Typology: mysqlEnum("ctx01Typology", [
    "Residential",
    "Mixed-use",
    "Hospitality",
    "Office",
  ]).default("Residential"),
  ctx02Scale: mysqlEnum("ctx02Scale", ["Small", "Medium", "Large"]).default(
    "Medium"
  ),
  ctx03Gfa: decimal("ctx03Gfa", { precision: 12, scale: 2 }),
  ctx04Location: mysqlEnum("ctx04Location", [
    "Prime",
    "Secondary",
    "Emerging",
  ]).default("Secondary"),
  ctx05Horizon: mysqlEnum("ctx05Horizon", [
    "0-12m",
    "12-24m",
    "24-36m",
    "36m+",
  ]).default("12-24m"),

  // Strategy variables (1-5)
  str01BrandClarity: int("str01BrandClarity").default(3),
  str02Differentiation: int("str02Differentiation").default(3),
  str03BuyerMaturity: int("str03BuyerMaturity").default(3),

  // Market variables
  mkt01Tier: mysqlEnum("mkt01Tier", [
    "Mid",
    "Upper-mid",
    "Luxury",
    "Ultra-luxury",
  ]).default("Upper-mid"),
  mkt02Competitor: int("mkt02Competitor").default(3),
  mkt03Trend: int("mkt03Trend").default(3),

  // Financial variables
  fin01BudgetCap: decimal("fin01BudgetCap", { precision: 10, scale: 2 }),
  fin02Flexibility: int("fin02Flexibility").default(3),
  fin03ShockTolerance: int("fin03ShockTolerance").default(3),
  fin04SalesPremium: int("fin04SalesPremium").default(3),

  // Design variables
  des01Style: mysqlEnum("des01Style", [
    "Modern",
    "Contemporary",
    "Minimal",
    "Classic",
    "Fusion",
    "Other",
  ]).default("Modern"),
  des02MaterialLevel: int("des02MaterialLevel").default(3),
  des03Complexity: int("des03Complexity").default(3),
  des04Experience: int("des04Experience").default(3),
  des05Sustainability: int("des05Sustainability").default(2),

  // Execution variables
  exe01SupplyChain: int("exe01SupplyChain").default(3),
  exe02Contractor: int("exe02Contractor").default(3),
  exe03Approvals: int("exe03Approvals").default(2),
  exe04QaMaturity: int("exe04QaMaturity").default(3),

  // Add-on variables
  add01SampleKit: boolean("add01SampleKit").default(false),
  add02PortfolioMode: boolean("add02PortfolioMode").default(false),
  add03DashboardExport: boolean("add03DashboardExport").default(true),

  modelVersionId: int("modelVersionId"),
  benchmarkVersionId: int("benchmarkVersionId"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  lockedAt: timestamp("lockedAt"),
});

export type Project = typeof projects.$inferSelect;
export type InsertProject = typeof projects.$inferInsert;

// ─── Direction Candidates ────────────────────────────────────────────────────
export const directionCandidates = mysqlTable("direction_candidates", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  isPrimary: boolean("isPrimary").default(false),
  des01Style: mysqlEnum("des01Style", [
    "Modern",
    "Contemporary",
    "Minimal",
    "Classic",
    "Fusion",
    "Other",
  ]),
  des02MaterialLevel: int("des02MaterialLevel"),
  des03Complexity: int("des03Complexity"),
  des04Experience: int("des04Experience"),
  fin01BudgetCap: decimal("fin01BudgetCap", { precision: 10, scale: 2 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type DirectionCandidate = typeof directionCandidates.$inferSelect;
export type InsertDirectionCandidate = typeof directionCandidates.$inferInsert;

// ─── Score Matrices ──────────────────────────────────────────────────────────
export const scoreMatrices = mysqlTable("score_matrices", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  directionId: int("directionId"),
  modelVersionId: int("modelVersionId").notNull(),
  benchmarkVersionId: int("benchmarkVersionId"),
  saScore: decimal("saScore", { precision: 6, scale: 2 }).notNull(),
  ffScore: decimal("ffScore", { precision: 6, scale: 2 }).notNull(),
  mpScore: decimal("mpScore", { precision: 6, scale: 2 }).notNull(),
  dsScore: decimal("dsScore", { precision: 6, scale: 2 }).notNull(),
  erScore: decimal("erScore", { precision: 6, scale: 2 }).notNull(),
  compositeScore: decimal("compositeScore", {
    precision: 6,
    scale: 2,
  }).notNull(),
  riskScore: decimal("riskScore", { precision: 6, scale: 2 }).notNull(),
  rasScore: decimal("rasScore", { precision: 6, scale: 2 }).notNull(),
  confidenceScore: decimal("confidenceScore", {
    precision: 6,
    scale: 2,
  }).notNull(),
  decisionStatus: mysqlEnum("decisionStatus", [
    "validated",
    "conditional",
    "not_validated",
  ]).notNull(),
  penalties: json("penalties"),
  riskFlags: json("riskFlags"),
  dimensionWeights: json("dimensionWeights").notNull(),
  variableContributions: json("variableContributions").notNull(),
  conditionalActions: json("conditionalActions"),
  inputSnapshot: json("inputSnapshot").notNull(),
  budgetFitMethod: varchar("budgetFitMethod", { length: 32 }),
  computedAt: timestamp("computedAt").defaultNow().notNull(),
});

export type ScoreMatrix = typeof scoreMatrices.$inferSelect;
export type InsertScoreMatrix = typeof scoreMatrices.$inferInsert;

// ─── Scenarios ───────────────────────────────────────────────────────────────
export const scenarios = mysqlTable("scenarios", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  orgId: int("orgId"),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  variableOverrides: json("variableOverrides"),
  isTemplate: boolean("isTemplate").default(false),
  templateKey: varchar("templateKey", { length: 64 }),
  scoreMatrixId: int("scoreMatrixId"),
  rasScore: decimal("rasScore", { precision: 6, scale: 2 }),
  isDominant: boolean("isDominant").default(false),
  stabilityScore: decimal("stabilityScore", { precision: 6, scale: 2 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Scenario = typeof scenarios.$inferSelect;
export type InsertScenario = typeof scenarios.$inferInsert;

// ─── Benchmark Data (Expanded) ──────────────────────────────────────────────
export const benchmarkData = mysqlTable("benchmark_data", {
  id: int("id").autoincrement().primaryKey(),
  typology: varchar("typology", { length: 64 }).notNull(),
  location: varchar("location", { length: 64 }).notNull(),
  marketTier: varchar("marketTier", { length: 64 }).notNull(),
  materialLevel: int("materialLevel").notNull(),
  roomType: varchar("roomType", { length: 64 }).default("General"),
  costPerSqftLow: decimal("costPerSqftLow", { precision: 10, scale: 2 }),
  costPerSqftMid: decimal("costPerSqftMid", { precision: 10, scale: 2 }),
  costPerSqftHigh: decimal("costPerSqftHigh", { precision: 10, scale: 2 }),
  avgSellingPrice: decimal("avgSellingPrice", { precision: 10, scale: 2 }),
  absorptionRate: decimal("absorptionRate", { precision: 6, scale: 4 }),
  competitiveDensity: int("competitiveDensity"),
  differentiationIndex: decimal("differentiationIndex", { precision: 6, scale: 4 }),
  complexityMultiplier: decimal("complexityMultiplier", { precision: 6, scale: 4 }),
  timelineRiskMultiplier: decimal("timelineRiskMultiplier", { precision: 6, scale: 4 }),
  buyerPreferenceWeights: json("buyerPreferenceWeights"),
  sourceType: mysqlEnum("sourceType", [
    "synthetic",
    "client_provided",
    "curated",
  ]).default("synthetic"),
  sourceNote: text("sourceNote"),
  dataYear: int("dataYear"),
  region: varchar("region", { length: 64 }).default("UAE"),
  benchmarkVersionId: int("benchmarkVersionId"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type BenchmarkData = typeof benchmarkData.$inferSelect;
export type InsertBenchmarkData = typeof benchmarkData.$inferInsert;

// ─── Project Intelligence Warehouse (V2) ───────────────────────────────────
export const projectIntelligence = mysqlTable("project_intelligence", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scoreMatrixId: int("scoreMatrixId").notNull(),
  benchmarkVersionId: int("benchmarkVersionId"),
  modelVersionId: int("modelVersionId"),
  costDeltaVsBenchmark: decimal("costDeltaVsBenchmark", { precision: 10, scale: 2 }),
  uniquenessIndex: decimal("uniquenessIndex", { precision: 6, scale: 4 }),
  feasibilityFlags: json("feasibilityFlags"),
  reworkRiskIndex: decimal("reworkRiskIndex", { precision: 6, scale: 4 }),
  procurementComplexity: decimal("procurementComplexity", { precision: 6, scale: 4 }),
  tierPercentile: decimal("tierPercentile", { precision: 6, scale: 4 }),
  styleFamily: varchar("styleFamily", { length: 64 }),
  costBand: varchar("costBand", { length: 32 }),
  inputSnapshot: json("inputSnapshot"),
  scoreSnapshot: json("scoreSnapshot"),
  computedAt: timestamp("computedAt").defaultNow().notNull(),
});

export type ProjectIntelligence = typeof projectIntelligence.$inferSelect;
export type InsertProjectIntelligence = typeof projectIntelligence.$inferInsert;

// ─── Report Instances ────────────────────────────────────────────────────────
export const reportInstances = mysqlTable("report_instances", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scoreMatrixId: int("scoreMatrixId").notNull(),
  reportType: mysqlEnum("reportType", [
    "executive_pack",
    "full_technical",
    "tender_brief",
    "executive_decision_pack",
    "design_brief_rfq",
    "marketing_starter",
    "validation_summary",
    "design_brief",
    "rfq_pack",
    "full_report",
    "marketing_prelaunch",
  ]).notNull(),
  fileUrl: text("fileUrl"),
  bundleUrl: text("bundleUrl"),
  content: json("content"),
  benchmarkVersionId: int("benchmarkVersionId"),
  modelVersionId: int("modelVersionId"),
  generatedAt: timestamp("generatedAt").defaultNow().notNull(),
  generatedBy: int("generatedBy"),
});

export type ReportInstance = typeof reportInstances.$inferSelect;
export type InsertReportInstance = typeof reportInstances.$inferInsert;

// ─── ROI Configurations (V2) ───────────────────────────────────────────────
export const roiConfigs = mysqlTable("roi_configs", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 128 }).notNull(),
  isActive: boolean("isActive").default(false).notNull(),
  hourlyRate: decimal("hourlyRate", { precision: 10, scale: 2 }).default("350").notNull(),
  reworkCostPct: decimal("reworkCostPct", { precision: 6, scale: 4 }).default("0.12").notNull(),
  tenderIterationCost: decimal("tenderIterationCost", { precision: 10, scale: 2 }).default("25000").notNull(),
  designCycleCost: decimal("designCycleCost", { precision: 10, scale: 2 }).default("45000").notNull(),
  budgetVarianceMultiplier: decimal("budgetVarianceMultiplier", { precision: 6, scale: 4 }).default("0.08").notNull(),
  timeAccelerationWeeks: int("timeAccelerationWeeks").default(6),
  conservativeMultiplier: decimal("conservativeMultiplier", { precision: 6, scale: 4 }).default("0.60").notNull(),
  aggressiveMultiplier: decimal("aggressiveMultiplier", { precision: 6, scale: 4 }).default("1.40").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
});

export type RoiConfig = typeof roiConfigs.$inferSelect;
export type InsertRoiConfig = typeof roiConfigs.$inferInsert;

// ─── Webhook Configurations (V2) ───────────────────────────────────────────
export const webhookConfigs = mysqlTable("webhook_configs", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  url: text("url").notNull(),
  secret: varchar("secret", { length: 255 }),
  events: json("events").notNull(),
  fieldMapping: json("fieldMapping"),
  isActive: boolean("isActive").default(true).notNull(),
  lastTriggeredAt: timestamp("lastTriggeredAt"),
  lastStatus: int("lastStatus"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
});

export type WebhookConfig = typeof webhookConfigs.$inferSelect;
export type InsertWebhookConfig = typeof webhookConfigs.$inferInsert;

// ─── Project Assets (V2.8 — Evidence Vault) ────────────────────────────────
export const projectAssets = mysqlTable("project_assets", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  filename: varchar("filename", { length: 512 }).notNull(),
  mimeType: varchar("mimeType", { length: 128 }).notNull(),
  sizeBytes: int("sizeBytes").notNull(),
  storagePath: text("storagePath").notNull(),
  storageUrl: text("storageUrl"),
  checksum: varchar("checksum", { length: 128 }),
  uploadedBy: int("uploadedBy").notNull(),
  category: mysqlEnum("category", [
    "brief",
    "brand",
    "budget",
    "competitor",
    "inspiration",
    "material",
    "sales",
    "legal",
    "mood_image",
    "material_board",
    "marketing_hero",
    "generated",
    "other",
  ]).default("other").notNull(),
  tags: json("tags"), // string[]
  notes: text("notes"),
  isClientVisible: boolean("isClientVisible").default(true).notNull(),
  uploadedAt: timestamp("uploadedAt").defaultNow().notNull(),
});

export type ProjectAsset = typeof projectAssets.$inferSelect;
export type InsertProjectAsset = typeof projectAssets.$inferInsert;

// ─── Asset Links (V2.8 — Evidence Traceability) ────────────────────────────
export const assetLinks = mysqlTable("asset_links", {
  id: int("id").autoincrement().primaryKey(),
  assetId: int("assetId").notNull(),
  linkType: mysqlEnum("linkType", [
    "evaluation",
    "report",
    "scenario",
    "material_board",
    "design_brief",
    "visual",
  ]).notNull(),
  linkId: int("linkId").notNull(), // ID of the linked entity
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type AssetLink = typeof assetLinks.$inferSelect;
export type InsertAssetLink = typeof assetLinks.$inferInsert;

// ─── Design Briefs (V2.8 — Design Direction Generator) ─────────────────────
export const designBriefs = mysqlTable("design_briefs", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scenarioId: int("scenarioId"), // optional: brief for a specific scenario
  version: int("version").default(1).notNull(),
  // 7 sections as JSON
  projectIdentity: json("projectIdentity").notNull(),
  positioningStatement: text("positioningStatement").notNull(),
  styleMood: json("styleMood").notNull(),
  materialGuidance: json("materialGuidance").notNull(),
  budgetGuardrails: json("budgetGuardrails").notNull(),
  procurementConstraints: json("procurementConstraints").notNull(),
  deliverablesChecklist: json("deliverablesChecklist").notNull(),
  // Metadata
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type DesignBrief = typeof designBriefs.$inferSelect;
export type InsertDesignBrief = typeof designBriefs.$inferInsert;

// ─── Generated Visuals (V2.8 — nano banana) ────────────────────────────────
export const generatedVisuals = mysqlTable("generated_visuals", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scenarioId: int("scenarioId"),
  type: mysqlEnum("type", ["mood", "material_board", "hero"]).notNull(),
  promptJson: json("promptJson").notNull(),
  modelVersion: varchar("modelVersion", { length: 64 }).default("nano-banana-v1"),
  imageAssetId: int("imageAssetId"), // FK to project_assets
  status: mysqlEnum("status", ["pending", "generating", "completed", "failed"]).default("pending").notNull(),
  errorMessage: text("errorMessage"),
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type GeneratedVisual = typeof generatedVisuals.$inferSelect;
export type InsertGeneratedVisual = typeof generatedVisuals.$inferInsert;

// ─── Material Boards (V2.8 — Board Composer) ────────────────────────────────
export const materialBoards = mysqlTable("material_boards", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scenarioId: int("scenarioId"),
  boardName: varchar("boardName", { length: 255 }).notNull(),
  boardJson: json("boardJson").notNull(), // materials/finishes/ff&e items
  boardImageAssetId: int("boardImageAssetId"), // FK to project_assets
  benchmarkVersionId: int("benchmarkVersionId"),
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type MaterialBoard = typeof materialBoards.$inferSelect;
export type InsertMaterialBoard = typeof materialBoards.$inferInsert;

// ─── Materials Catalog (V2.8 — FF&E Library) ────────────────────────────────
export const materialsCatalog = mysqlTable("materials_catalog", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  category: mysqlEnum("category", [
    "tile",
    "stone",
    "wood",
    "metal",
    "fabric",
    "glass",
    "paint",
    "wallpaper",
    "lighting",
    "furniture",
    "fixture",
    "accessory",
    "other",
  ]).notNull(),
  tier: mysqlEnum("tier", ["economy", "mid", "premium", "luxury", "ultra_luxury"]).notNull(),
  typicalCostLow: decimal("typicalCostLow", { precision: 10, scale: 2 }),
  typicalCostHigh: decimal("typicalCostHigh", { precision: 10, scale: 2 }),
  costUnit: varchar("costUnit", { length: 32 }).default("AED/sqm"),
  leadTimeDays: int("leadTimeDays"),
  leadTimeBand: mysqlEnum("leadTimeBand", ["short", "medium", "long", "critical"]).default("medium"),
  regionAvailability: json("regionAvailability"), // string[]
  supplierName: varchar("supplierName", { length: 255 }),
  supplierContact: varchar("supplierContact", { length: 255 }),
  supplierUrl: text("supplierUrl"),
  imageUrl: text("imageUrl"),
  notes: text("notes"),
  isActive: boolean("isActive").default(true).notNull(),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type MaterialCatalogItem = typeof materialsCatalog.$inferSelect;
export type InsertMaterialCatalogItem = typeof materialsCatalog.$inferInsert;

// ─── Materials to Boards (V2.8 — Join Table) ────────────────────────────────
export const materialsToBoards = mysqlTable("materials_to_boards", {
  id: int("id").autoincrement().primaryKey(),
  boardId: int("boardId").notNull(),
  materialId: int("materialId").notNull(),
  quantity: decimal("quantity", { precision: 10, scale: 2 }),
  unitOfMeasure: varchar("unitOfMeasure", { length: 32 }),
  notes: text("notes"),
  sortOrder: int("sortOrder").default(0).notNull(),
  specNotes: text("specNotes"),
  costBandOverride: varchar("costBandOverride", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type MaterialToBoard = typeof materialsToBoards.$inferSelect;
export type InsertMaterialToBoard = typeof materialsToBoards.$inferInsert;

// ─── Prompt Templates (V2.8 — Admin-editable nano banana prompts) ───────────
export const promptTemplates = mysqlTable("prompt_templates", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId"),
  name: varchar("name", { length: 255 }).notNull(),
  type: mysqlEnum("type", ["mood", "material_board", "hero"]).notNull(),
  templateText: text("templateText").notNull(),
  variables: json("variables").notNull(), // string[] of variable names
  isActive: boolean("isActive").default(true).notNull(),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type PromptTemplate = typeof promptTemplates.$inferSelect;
export type InsertPromptTemplate = typeof promptTemplates.$inferInsert;

// ─── Comments (V2.8 — Collaboration) ────────────────────────────────────────
export const comments = mysqlTable("comments", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  entityType: mysqlEnum("entityType", [
    "design_brief",
    "material_board",
    "visual",
    "general",
  ]).notNull(),
  entityId: int("entityId"),
  userId: int("userId").notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Comment = typeof comments.$inferSelect;
export type InsertComment = typeof comments.$inferInsert;

// ─── Audit Logs ──────────────────────────────────────────────────────────────
export const auditLogs = mysqlTable("audit_logs", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId"),
  userId: int("userId"),
  action: varchar("action", { length: 128 }).notNull(),
  entityType: varchar("entityType", { length: 64 }).notNull(),
  entityId: int("entityId"),
  details: json("details"),
  benchmarkVersionId: int("benchmarkVersionId"),
  modelVersionId: int("modelVersionId"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  ipAddress: varchar("ipAddress", { length: 64 }),
});

export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertAuditLog = typeof auditLogs.$inferInsert;

// ─── Override Records ────────────────────────────────────────────────────────
export const overrideRecords = mysqlTable("override_records", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  userId: int("userId").notNull(),
  overrideType: mysqlEnum("overrideType", [
    "strategic",
    "market_insight",
    "risk_adjustment",
    "experimental",
  ]).notNull(),
  authorityLevel: int("authorityLevel").notNull(),
  originalValue: json("originalValue").notNull(),
  overrideValue: json("overrideValue").notNull(),
  justification: text("justification").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type OverrideRecord = typeof overrideRecords.$inferSelect;
export type InsertOverrideRecord = typeof overrideRecords.$inferInsert;

// ─── Logic Versions (V2.10 — Logic/Policy Registry) ──────────────────────────
export const logicVersions = mysqlTable("logic_versions", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 128 }).notNull(),
  status: mysqlEnum("status", ["draft", "published", "archived"]).default("draft").notNull(),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  publishedAt: timestamp("publishedAt"),
  notes: text("notes"),
});

export type LogicVersion = typeof logicVersions.$inferSelect;
export type InsertLogicVersion = typeof logicVersions.$inferInsert;

// ─── Logic Weights (V2.10) ───────────────────────────────────────────────────
export const logicWeights = mysqlTable("logic_weights", {
  id: int("id").autoincrement().primaryKey(),
  logicVersionId: int("logicVersionId").notNull(),
  dimension: varchar("dimension", { length: 32 }).notNull(), // sa, ff, mp, ds, er
  weight: decimal("weight", { precision: 6, scale: 4 }).notNull(),
});

export type LogicWeight = typeof logicWeights.$inferSelect;
export type InsertLogicWeight = typeof logicWeights.$inferInsert;

// ─── Logic Thresholds (V2.10) ────────────────────────────────────────────────
export const logicThresholds = mysqlTable("logic_thresholds", {
  id: int("id").autoincrement().primaryKey(),
  logicVersionId: int("logicVersionId").notNull(),
  ruleKey: varchar("ruleKey", { length: 128 }).notNull(),
  thresholdValue: decimal("thresholdValue", { precision: 10, scale: 4 }).notNull(),
  comparator: mysqlEnum("comparator", ["gt", "gte", "lt", "lte", "eq", "neq"]).notNull(),
  notes: text("notes"),
});

export type LogicThreshold = typeof logicThresholds.$inferSelect;
export type InsertLogicThreshold = typeof logicThresholds.$inferInsert;

// ─── Logic Change Log (V2.10) ────────────────────────────────────────────────
export const logicChangeLog = mysqlTable("logic_change_log", {
  id: int("id").autoincrement().primaryKey(),
  logicVersionId: int("logicVersionId").notNull(),
  actor: int("actor").notNull(),
  changeSummary: text("changeSummary").notNull(),
  rationale: text("rationale").notNull(),
  status: mysqlEnum("status", ["applied", "proposed", "rejected"]).default("applied").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type LogicChangeLogEntry = typeof logicChangeLog.$inferSelect;
export type InsertLogicChangeLogEntry = typeof logicChangeLog.$inferInsert;

// ─── Pattern Library (V5-07) ──────────────────────────────────────────────────
export const decisionPatterns = mysqlTable("decision_patterns", {
  id: int("id").autoincrement().primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  category: mysqlEnum("category", ["risk_indicator", "success_driver", "cost_anomaly"]).notNull(),
  conditions: json("conditions").notNull(), // array of logic defining the pattern
  matchCount: int("matchCount").default(0).notNull(), // times it appeared
  reliabilityScore: decimal("reliabilityScore", { precision: 5, scale: 2 }).default("0.00").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type DecisionPattern = typeof decisionPatterns.$inferSelect;
export type InsertDecisionPattern = typeof decisionPatterns.$inferInsert;

export const projectPatternMatches = mysqlTable("project_pattern_matches", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  patternId: int("patternId").notNull(),
  matchedAt: timestamp("matchedAt").defaultNow().notNull(),
  confidence: decimal("confidence", { precision: 5, scale: 2 }).default("1.00").notNull(),
  contextSnapshot: json("contextSnapshot"), // snapshot of scores during match
});

export type ProjectPatternMatch = typeof projectPatternMatches.$inferSelect;
export type InsertProjectPatternMatch = typeof projectPatternMatches.$inferInsert;


// ─── Scenario Inputs (V2.11) ─────────────────────────────────────────────────
export const scenarioInputs = mysqlTable("scenario_inputs", {
  id: int("id").autoincrement().primaryKey(),
  scenarioId: int("scenarioId").notNull(),
  jsonInput: json("jsonInput").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ScenarioInput = typeof scenarioInputs.$inferSelect;
export type InsertScenarioInput = typeof scenarioInputs.$inferInsert;

// ─── Scenario Outputs (V2.11) ────────────────────────────────────────────────
export const scenarioOutputs = mysqlTable("scenario_outputs", {
  id: int("id").autoincrement().primaryKey(),
  scenarioId: int("scenarioId").notNull(),
  scoreJson: json("scoreJson").notNull(),
  roiJson: json("roiJson"),
  riskJson: json("riskJson"),
  boardCostJson: json("boardCostJson"),
  benchmarkVersionId: int("benchmarkVersionId"),
  logicVersionId: int("logicVersionId"),
  computedAt: timestamp("computedAt").defaultNow().notNull(),
});

export type ScenarioOutput = typeof scenarioOutputs.$inferSelect;
export type InsertScenarioOutput = typeof scenarioOutputs.$inferInsert;

// ─── Scenario Comparisons (V2.11) ────────────────────────────────────────────
export const scenarioComparisons = mysqlTable("scenario_comparisons", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  baselineScenarioId: int("baselineScenarioId").notNull(),
  comparedScenarioIds: json("comparedScenarioIds").notNull(), // number[]
  decisionNote: text("decisionNote"),
  comparisonResult: json("comparisonResult"), // computed tradeoffs
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ScenarioComparison = typeof scenarioComparisons.$inferSelect;
export type InsertScenarioComparison = typeof scenarioComparisons.$inferInsert;

// ─── Project Outcomes (V2.13) ────────────────────────────────────────────────
export const projectOutcomes = mysqlTable("project_outcomes", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  procurementActualCosts: json("procurementActualCosts"),
  leadTimesActual: json("leadTimesActual"),
  rfqResults: json("rfqResults"),
  adoptionMetrics: json("adoptionMetrics"),

  // V5 Fields
  actualFitoutCostPerSqm: decimal("actualFitoutCostPerSqm", { precision: 10, scale: 2 }),
  actualTotalCost: decimal("actualTotalCost", { precision: 15, scale: 2 }),
  projectDeliveredOnTime: boolean("projectDeliveredOnTime"),
  reworkOccurred: boolean("reworkOccurred"),
  reworkCostAed: decimal("reworkCostAed", { precision: 15, scale: 2 }),
  clientSatisfactionScore: int("clientSatisfactionScore"),
  tenderIterations: int("tenderIterations"),
  keyLessonsLearned: text("keyLessonsLearned"),

  capturedAt: timestamp("capturedAt").defaultNow().notNull(),
  capturedBy: int("capturedBy"),
});

export type ProjectOutcome = typeof projectOutcomes.$inferSelect;
export type InsertProjectOutcome = typeof projectOutcomes.$inferInsert;

export const outcomeComparisons = mysqlTable("outcome_comparisons", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  comparedAt: timestamp("comparedAt").defaultNow().notNull(),

  // Cost accuracy
  predictedCostMid: decimal("predictedCostMid", { precision: 15, scale: 2 }),
  actualCost: decimal("actualCost", { precision: 15, scale: 2 }),
  costDeltaPct: decimal("costDeltaPct", { precision: 10, scale: 4 }),
  costAccuracyBand: mysqlEnum("costAccuracyBand", ["within_10pct", "within_20pct", "outside_20pct", "no_prediction"]).notNull(),

  // Score accuracy
  predictedComposite: decimal("predictedComposite", { precision: 5, scale: 4 }).notNull(),
  predictedDecision: varchar("predictedDecision", { length: 64 }).notNull(),
  actualOutcomeSuccess: boolean("actualOutcomeSuccess").notNull(),
  scorePredictionCorrect: boolean("scorePredictionCorrect").notNull(),

  // Risk accuracy
  predictedRisk: decimal("predictedRisk", { precision: 5, scale: 4 }).notNull(),
  actualReworkOccurred: boolean("actualReworkOccurred").notNull(),
  riskPredictionCorrect: boolean("riskPredictionCorrect").notNull(),

  // Delta summary
  overallAccuracyGrade: mysqlEnum("overallAccuracyGrade", ["A", "B", "C", "insufficient_data"]).notNull(),
  learningSignals: json("learningSignals"),
  rawComparison: json("rawComparison"),
});

export type OutcomeComparison = typeof outcomeComparisons.$inferSelect;
export type InsertOutcomeComparison = typeof outcomeComparisons.$inferInsert;

export const accuracySnapshots = mysqlTable("accuracy_snapshots", {
  id: int("id").autoincrement().primaryKey(),
  snapshotDate: timestamp("snapshotDate").defaultNow().notNull(),

  totalComparisons: int("totalComparisons").notNull(),
  withCostPrediction: int("withCostPrediction").notNull(),
  withOutcomePrediction: int("withOutcomePrediction").notNull(),

  // Cost accuracy
  costWithin10Pct: int("costWithin10Pct").notNull(),
  costWithin20Pct: int("costWithin20Pct").notNull(),
  costOutside20Pct: int("costOutside20Pct").notNull(),
  costMaePct: decimal("costMaePct", { precision: 8, scale: 4 }),
  costTrend: mysqlEnum("costTrend", ["improving", "stable", "degrading", "insufficient_data"]).notNull(),

  // Score accuracy
  scoreCorrectPredictions: int("scoreCorrectPredictions").notNull(),
  scoreIncorrectPredictions: int("scoreIncorrectPredictions").notNull(),
  scoreAccuracyRate: decimal("scoreAccuracyRate", { precision: 8, scale: 4 }).notNull(),
  scoreTrend: mysqlEnum("scoreTrend", ["improving", "stable", "degrading", "insufficient_data"]).notNull(),

  // Risk accuracy
  riskCorrectPredictions: int("riskCorrectPredictions").notNull(),
  riskIncorrectPredictions: int("riskIncorrectPredictions").notNull(),
  riskAccuracyRate: decimal("riskAccuracyRate", { precision: 8, scale: 4 }).notNull(),
  riskTrend: mysqlEnum("riskTrend", ["improving", "stable", "degrading", "insufficient_data"]).notNull(),

  overallPlatformAccuracy: decimal("overallPlatformAccuracy", { precision: 8, scale: 4 }).notNull(),
  gradeA: int("gradeA").notNull(),
  gradeB: int("gradeB").notNull(),
  gradeC: int("gradeC").notNull(),
});

export type AccuracySnapshot = typeof accuracySnapshots.$inferSelect;
export type InsertAccuracySnapshot = typeof accuracySnapshots.$inferInsert;

// ─── Benchmark Suggestions (V2.13) ──────────────────────────────────────────
export const benchmarkSuggestions = mysqlTable("benchmark_suggestions", {
  id: int("id").autoincrement().primaryKey(),
  basedOnOutcomesQuery: text("basedOnOutcomesQuery"),
  suggestedChanges: json("suggestedChanges").notNull(),
  confidence: decimal("confidence", { precision: 6, scale: 4 }),
  status: mysqlEnum("status", ["pending", "accepted", "rejected"]).default("pending").notNull(),
  reviewerNotes: text("reviewerNotes"),
  reviewedBy: int("reviewedBy"),
  reviewedAt: timestamp("reviewedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type BenchmarkSuggestion = typeof benchmarkSuggestions.$inferSelect;
export type InsertBenchmarkSuggestion = typeof benchmarkSuggestions.$inferInsert;

// ═══════════════════════════════════════════════════════════════════════════════
// Stage 1 — Market Intelligence Layer V1
// ═══════════════════════════════════════════════════════════════════════════════

// ─── Source Registry (Stage 1) ──────────────────────────────────────────────
export const sourceRegistry = mysqlTable("source_registry", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  url: text("url").notNull(),
  sourceType: mysqlEnum("sourceType", [
    "supplier_catalog",
    "manufacturer_catalog",
    "developer_brochure",
    "industry_report",
    "government_tender",
    "procurement_portal",
    "trade_publication",
    "retailer_listing",
    "aggregator",
    "other",
  ]).notNull(),
  reliabilityDefault: mysqlEnum("reliabilityDefault", ["A", "B", "C"]).default("B").notNull(),
  isWhitelisted: boolean("isWhitelisted").default(true).notNull(),
  region: varchar("region", { length: 64 }).default("UAE"),
  notes: text("notes"),
  addedBy: int("addedBy"),
  isActive: boolean("isActive").default(true).notNull(),
  lastSuccessfulFetch: timestamp("lastSuccessfulFetch"),

  // DFE Fields
  scrapeConfig: json("scrapeConfig"),
  scrapeSchedule: varchar("scrapeSchedule", { length: 64 }),
  scrapeMethod: mysqlEnum("scrapeMethod", [
    "html_llm",
    "html_rules",
    "json_api",
    "rss_feed",
    "csv_upload",
    "email_forward",
  ]).default("html_llm").notNull(),
  scrapeHeaders: json("scrapeHeaders"),
  extractionHints: text("extractionHints"),
  priceFieldMapping: json("priceFieldMapping"),
  lastScrapedAt: timestamp("lastScrapedAt"),
  lastScrapedStatus: mysqlEnum("lastScrapedStatus", ["success", "partial", "failed", "never"]).default("never").notNull(),
  lastRecordCount: int("lastRecordCount").default(0).notNull(),
  consecutiveFailures: int("consecutiveFailures").default(0).notNull(),
  requestDelayMs: int("requestDelayMs").default(2000).notNull(),

  addedAt: timestamp("addedAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type SourceRegistryEntry = typeof sourceRegistry.$inferSelect;
export type InsertSourceRegistryEntry = typeof sourceRegistry.$inferInsert;

// ─── Evidence Records (Stage 1) ─────────────────────────────────────────────
export const evidenceRecords = mysqlTable("evidence_records", {
  id: int("id").autoincrement().primaryKey(),
  recordId: varchar("recordId", { length: 64 }).notNull().unique(), // MYR-PE-XXXX
  projectId: int("projectId"), // optional: can be global evidence
  orgId: int("orgId"),
  sourceRegistryId: int("sourceRegistryId"), // FK to source_registry
  category: mysqlEnum("category", [
    "floors",
    "walls",
    "ceilings",
    "joinery",
    "lighting",
    "sanitary",
    "kitchen",
    "hardware",
    "ffe",
    "other",
  ]).notNull(),
  itemName: varchar("itemName", { length: 255 }).notNull(),
  specClass: varchar("specClass", { length: 128 }),
  priceMin: decimal("priceMin", { precision: 12, scale: 2 }),
  priceTypical: decimal("priceTypical", { precision: 12, scale: 2 }),
  priceMax: decimal("priceMax", { precision: 12, scale: 2 }),
  unit: varchar("unit", { length: 32 }).notNull(), // sqm, lm, set, piece, etc.
  currencyOriginal: varchar("currencyOriginal", { length: 8 }).default("AED"),
  currencyAed: decimal("currencyAed", { precision: 12, scale: 2 }), // normalized to AED
  fxRate: decimal("fxRate", { precision: 10, scale: 6 }),
  fxSource: text("fxSource"),
  sourceUrl: text("sourceUrl").notNull(),
  publisher: varchar("publisher", { length: 255 }),
  captureDate: timestamp("captureDate").notNull(),
  reliabilityGrade: mysqlEnum("reliabilityGrade", ["A", "B", "C"]).notNull(),
  confidenceScore: int("confidenceScore").notNull(), // 0-100
  extractedSnippet: text("extractedSnippet"),
  notes: text("notes"),
  // V2.2 metadata fields
  title: varchar("title", { length: 512 }),
  evidencePhase: mysqlEnum("evidencePhase", ["concept", "schematic", "detailed_design", "tender", "procurement", "construction", "handover"]),
  author: varchar("author", { length: 255 }),
  confidentiality: mysqlEnum("confidentiality", ["public", "internal", "confidential", "restricted"]).default("internal"),
  tags: json("tags"), // string[]
  fileUrl: text("fileUrl"), // S3 signed URL for attached evidence file
  fileKey: varchar("fileKey", { length: 512 }), // S3 key for the file
  fileMimeType: varchar("fileMimeType", { length: 128 }),
  runId: varchar("runId", { length: 64 }), // links to intelligence_audit_log
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type EvidenceRecord = typeof evidenceRecords.$inferSelect;
export type InsertEvidenceRecord = typeof evidenceRecords.$inferInsert;

// ─── Benchmark Proposals (Stage 1) ──────────────────────────────────────────
export const benchmarkProposals = mysqlTable("benchmark_proposals", {
  id: int("id").autoincrement().primaryKey(),
  benchmarkKey: varchar("benchmarkKey", { length: 255 }).notNull(), // category:tier:unit
  currentTypical: decimal("currentTypical", { precision: 12, scale: 2 }),
  currentMin: decimal("currentMin", { precision: 12, scale: 2 }),
  currentMax: decimal("currentMax", { precision: 12, scale: 2 }),
  proposedP25: decimal("proposedP25", { precision: 12, scale: 2 }).notNull(),
  proposedP50: decimal("proposedP50", { precision: 12, scale: 2 }).notNull(),
  proposedP75: decimal("proposedP75", { precision: 12, scale: 2 }).notNull(),
  weightedMean: decimal("weightedMean", { precision: 12, scale: 2 }).notNull(),
  deltaPct: decimal("deltaPct", { precision: 8, scale: 2 }), // % change from current
  evidenceCount: int("evidenceCount").notNull(),
  sourceDiversity: int("sourceDiversity").notNull(),
  reliabilityDist: json("reliabilityDist").notNull(), // { A: n, B: n, C: n }
  recencyDist: json("recencyDist").notNull(), // { recent: n, mid: n, old: n }
  confidenceScore: int("confidenceScore").notNull(), // 0-100
  impactNotes: text("impactNotes"),
  recommendation: mysqlEnum("recommendation", ["publish", "reject"]).notNull(),
  rejectionReason: text("rejectionReason"),
  // Review workflow
  status: mysqlEnum("status", ["pending", "approved", "rejected"]).default("pending").notNull(),
  reviewerNotes: text("reviewerNotes"),
  reviewedBy: int("reviewedBy"),
  reviewedAt: timestamp("reviewedAt"),
  // Snapshot linking
  benchmarkSnapshotId: int("benchmarkSnapshotId"),
  runId: varchar("runId", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type BenchmarkProposal = typeof benchmarkProposals.$inferSelect;
export type InsertBenchmarkProposal = typeof benchmarkProposals.$inferInsert;

// ─── Benchmark Snapshots (Stage 1) ──────────────────────────────────────────
export const benchmarkSnapshots = mysqlTable("benchmark_snapshots", {
  id: int("id").autoincrement().primaryKey(),
  benchmarkVersionId: int("benchmarkVersionId"),
  snapshotJson: json("snapshotJson").notNull(), // full benchmark state at time of snapshot
  description: text("description"),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type BenchmarkSnapshot = typeof benchmarkSnapshots.$inferSelect;
export type InsertBenchmarkSnapshot = typeof benchmarkSnapshots.$inferInsert;

// ─── Competitor Entities (Stage 1) ──────────────────────────────────────────
export const competitorEntities = mysqlTable("competitor_entities", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  headquarters: varchar("headquarters", { length: 255 }),
  segmentFocus: mysqlEnum("segmentFocus", [
    "affordable",
    "mid",
    "premium",
    "luxury",
    "ultra_luxury",
    "mixed",
  ]).default("mixed"),
  website: text("website"),
  logoUrl: text("logoUrl"),
  notes: text("notes"),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CompetitorEntity = typeof competitorEntities.$inferSelect;
export type InsertCompetitorEntity = typeof competitorEntities.$inferInsert;

// ─── Competitor Projects (Stage 1) ──────────────────────────────────────────
export const competitorProjects = mysqlTable("competitor_projects", {
  id: int("id").autoincrement().primaryKey(),
  competitorId: int("competitorId").notNull(), // FK to competitor_entities
  projectName: varchar("projectName", { length: 255 }).notNull(),
  location: varchar("location", { length: 255 }),
  segment: mysqlEnum("segment", [
    "affordable",
    "mid",
    "premium",
    "luxury",
    "ultra_luxury",
  ]),
  assetType: mysqlEnum("assetType", [
    "residential",
    "commercial",
    "hospitality",
    "mixed_use",
  ]).default("residential"),
  positioningKeywords: json("positioningKeywords"), // string[]
  interiorStyleSignals: json("interiorStyleSignals"), // string[]
  materialCues: json("materialCues"), // string[]
  amenityList: json("amenityList"), // string[]
  unitMix: text("unitMix"),
  priceIndicators: json("priceIndicators"), // { currency, min, max, per_unit }
  salesMessaging: json("salesMessaging"), // string[]
  differentiationClaims: json("differentiationClaims"), // string[]
  completionStatus: mysqlEnum("completionStatus", [
    "announced",
    "under_construction",
    "completed",
    "sold_out",
  ]),
  launchDate: varchar("launchDate", { length: 32 }),
  totalUnits: int("totalUnits"),
  architect: varchar("architect", { length: 255 }),
  interiorDesigner: varchar("interiorDesigner", { length: 255 }),
  sourceUrl: text("sourceUrl"),
  captureDate: timestamp("captureDate"),
  evidenceCitations: json("evidenceCitations"), // array of { field, snippet, source_url, capture_date }
  completenessScore: int("completenessScore"), // 0-100
  runId: varchar("runId", { length: 64 }),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CompetitorProject = typeof competitorProjects.$inferSelect;
export type InsertCompetitorProject = typeof competitorProjects.$inferInsert;

// ─── Trend Tags (Stage 1) ───────────────────────────────────────────────────
export const trendTags = mysqlTable("trend_tags", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 128 }).notNull().unique(),
  category: mysqlEnum("category", [
    "material_trend",
    "design_trend",
    "market_trend",
    "buyer_preference",
    "sustainability",
    "technology",
    "pricing",
    "other",
  ]).notNull(),
  description: text("description"),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type TrendTag = typeof trendTags.$inferSelect;
export type InsertTrendTag = typeof trendTags.$inferInsert;

// ─── Entity Tags (Stage 1 — Join Table) ─────────────────────────────────────
export const entityTags = mysqlTable("entity_tags", {
  id: int("id").autoincrement().primaryKey(),
  tagId: int("tagId").notNull(), // FK to trend_tags
  entityType: mysqlEnum("entityType", [
    "competitor_project",
    "scenario",
    "evidence_record",
    "project",
  ]).notNull(),
  entityId: int("entityId").notNull(),
  addedBy: int("addedBy"),
  addedAt: timestamp("addedAt").defaultNow().notNull(),
});

export type EntityTag = typeof entityTags.$inferSelect;
export type InsertEntityTag = typeof entityTags.$inferInsert;

// ─── Intelligence Audit Log (Stage 1) ───────────────────────────────────────
export const intelligenceAuditLog = mysqlTable("intelligence_audit_log", {
  id: int("id").autoincrement().primaryKey(),
  runType: mysqlEnum("runType", [
    "price_extraction",
    "competitor_extraction",
    "benchmark_proposal",
    "manual_entry",
  ]).notNull(),
  runId: varchar("runId", { length: 64 }).notNull().unique(),
  actor: int("actor"), // userId who triggered
  inputSummary: json("inputSummary"), // config/params used
  outputSummary: json("outputSummary"), // counts, coverage, errors
  sourcesProcessed: int("sourcesProcessed").default(0),
  recordsExtracted: int("recordsExtracted").default(0),
  errors: int("errors").default(0),
  errorDetails: json("errorDetails"),
  startedAt: timestamp("startedAt").notNull(),
  completedAt: timestamp("completedAt"),
});

export type IntelligenceAuditLogEntry = typeof intelligenceAuditLog.$inferSelect;
export type InsertIntelligenceAuditLogEntry = typeof intelligenceAuditLog.$inferInsert;

// ─── Evidence References (V2.2 — Evidence Traceability) ─────────────────────
export const evidenceReferences = mysqlTable("evidence_references", {
  id: int("id").autoincrement().primaryKey(),
  evidenceRecordId: int("evidenceRecordId").notNull(), // FK to evidence_records
  targetType: mysqlEnum("targetType", [
    "scenario",
    "decision_note",
    "explainability_driver",
    "design_brief",
    "report",
    "material_board",
    "pack_section",
  ]).notNull(),
  targetId: int("targetId").notNull(), // ID of the linked entity
  sectionLabel: varchar("sectionLabel", { length: 255 }), // e.g. "Materials Specification", "Cost Assumptions"
  citationText: text("citationText"), // inline citation snippet
  addedBy: int("addedBy"),
  addedAt: timestamp("addedAt").defaultNow().notNull(),
});

export type EvidenceReference = typeof evidenceReferences.$inferSelect;
export type InsertEvidenceReference = typeof evidenceReferences.$inferInsert;

// ─── Ingestion Runs (V2 — Live Market Ingestion) ──────────────────────────────
export const ingestionRuns = mysqlTable("ingestion_runs", {
  id: int("id").autoincrement().primaryKey(),
  runId: varchar("runId", { length: 64 }).notNull().unique(),
  trigger: mysqlEnum("trigger", ["manual", "scheduled", "api"]).notNull(),
  triggeredBy: int("triggeredBy"), // userId or null for scheduled
  status: mysqlEnum("status", ["running", "completed", "failed"]).default("running").notNull(),
  // Counts
  totalSources: int("totalSources").default(0).notNull(),
  sourcesSucceeded: int("sourcesSucceeded").default(0).notNull(),
  sourcesFailed: int("sourcesFailed").default(0).notNull(),
  recordsExtracted: int("recordsExtracted").default(0).notNull(),
  recordsInserted: int("recordsInserted").default(0).notNull(),
  duplicatesSkipped: int("duplicatesSkipped").default(0).notNull(),
  // Detail
  sourceBreakdown: json("sourceBreakdown"), // per-source { sourceId, name, status, extracted, inserted, duplicates, errors }
  errorSummary: json("errorSummary"), // [{ sourceId, error }]
  // Timing
  startedAt: timestamp("startedAt").notNull(),
  completedAt: timestamp("completedAt"),
  durationMs: int("durationMs"),
  // Metadata
  cronExpression: varchar("cronExpression", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type IngestionRun = typeof ingestionRuns.$inferSelect;
export type InsertIngestionRun = typeof ingestionRuns.$inferInsert;

// ─── Connector Health (V3 — Source Health Monitoring) ───────────────────────────
export const connectorHealth = mysqlTable("connector_health", {
  id: int("id").autoincrement().primaryKey(),
  runId: varchar("runId", { length: 64 }).notNull(), // FK to ingestion_runs.runId
  sourceId: varchar("sourceId", { length: 64 }).notNull(),
  sourceName: varchar("sourceName", { length: 255 }).notNull(),
  status: mysqlEnum("healthStatus", ["success", "partial", "failed"]).notNull(),
  httpStatusCode: int("httpStatusCode"),
  responseTimeMs: int("responseTimeMs"),
  recordsExtracted: int("recordsExtracted").default(0).notNull(),
  recordsInserted: int("recordsInserted").default(0).notNull(),
  duplicatesSkipped: int("duplicatesSkipped").default(0).notNull(),
  errorMessage: text("errorMessage"),
  errorType: varchar("errorType", { length: 64 }), // "dns_failure", "timeout", "http_error", "parse_error", "llm_error"
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ConnectorHealth = typeof connectorHealth.$inferSelect;
export type InsertConnectorHealth = typeof connectorHealth.$inferInsert;

// ─── Trend Snapshots (V3 — Analytical Intelligence) ──────────────────────────
export const trendSnapshots = mysqlTable("trend_snapshots", {
  id: int("id").autoincrement().primaryKey(),
  metric: varchar("metric", { length: 255 }).notNull(),
  category: varchar("category", { length: 128 }).notNull(),
  geography: varchar("geography", { length: 128 }).notNull(),
  dataPointCount: int("dataPointCount").default(0).notNull(),
  gradeACount: int("gradeACount").default(0).notNull(),
  gradeBCount: int("gradeBCount").default(0).notNull(),
  gradeCCount: int("gradeCCount").default(0).notNull(),
  uniqueSources: int("uniqueSources").default(0).notNull(),
  dateRangeStart: timestamp("dateRangeStart"),
  dateRangeEnd: timestamp("dateRangeEnd"),
  currentMA: decimal("currentMA", { precision: 14, scale: 4 }),
  previousMA: decimal("previousMA", { precision: 14, scale: 4 }),
  percentChange: decimal("percentChange", { precision: 10, scale: 6 }),
  direction: mysqlEnum("direction", ["rising", "falling", "stable", "insufficient_data"]).notNull(),
  anomalyCount: int("anomalyCount").default(0).notNull(),
  anomalyDetails: json("anomalyDetails"), // AnomalyFlag[]
  confidence: mysqlEnum("trendConfidence", ["high", "medium", "low", "insufficient"]).notNull(),
  narrative: text("narrative"),
  movingAverages: json("movingAverages"), // MovingAveragePoint[]
  ingestionRunId: varchar("ingestionRunId", { length: 64 }), // FK to ingestion_runs.runId
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type TrendSnapshot = typeof trendSnapshots.$inferSelect;
export type InsertTrendSnapshot = typeof trendSnapshots.$inferInsert;

// ─── Project Insights (V3 — Analytical Intelligence) ─────────────────────────
export const projectInsights = mysqlTable("project_insights", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId"), // nullable for system-wide insights
  insightType: mysqlEnum("insightType", [
    "cost_pressure",
    "market_opportunity",
    "competitor_alert",
    "trend_signal",
    "positioning_gap",
  ]).notNull(),
  severity: mysqlEnum("insightSeverity", ["critical", "warning", "info"]).notNull(),
  title: varchar("title", { length: 512 }).notNull(),
  body: text("body"),
  actionableRecommendation: text("actionableRecommendation"),
  confidenceScore: decimal("confidenceScore", { precision: 5, scale: 4 }),
  triggerCondition: text("triggerCondition"),
  dataPoints: json("dataPoints"),
  status: mysqlEnum("insightStatus", ["active", "acknowledged", "dismissed", "resolved"]).default("active").notNull(),
  acknowledgedBy: int("acknowledgedBy"),
  acknowledgedAt: timestamp("acknowledgedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ProjectInsight = typeof projectInsights.$inferSelect;
export type InsertProjectInsight = typeof projectInsights.$inferInsert;

export const priceChangeEvents = mysqlTable("price_change_events", {
  id: int("id").autoincrement().primaryKey(),
  itemName: varchar("itemName", { length: 255 }).notNull(),
  category: varchar("category", { length: 255 }).notNull(),
  sourceId: int("sourceId").notNull(),
  previousPrice: decimal("previousPrice", { precision: 12, scale: 2 }).notNull(),
  newPrice: decimal("newPrice", { precision: 12, scale: 2 }).notNull(),
  changePct: decimal("changePct", { precision: 10, scale: 6 }).notNull(),
  changeDirection: mysqlEnum("changeDirection", ["increased", "decreased"]).notNull(),
  severity: mysqlEnum("severity", ["significant", "notable", "minor", "none"]).notNull(),
  detectedAt: timestamp("detectedAt").defaultNow().notNull(),
});

export type PriceChangeEvent = typeof priceChangeEvents.$inferSelect;
export type InsertPriceChangeEvent = typeof priceChangeEvents.$inferInsert;

// ─── Platform Alerts (V6 — Autonomous Intelligence) ─────────────────────────
export const platformAlerts = mysqlTable("platform_alerts", {
  id: int("id").autoincrement().primaryKey(),
  alertType: mysqlEnum("alertType", [
    "price_shock",
    "project_at_risk",
    "accuracy_degraded",
    "pattern_warning",
    "benchmark_drift",
    "market_opportunity"
  ]).notNull(),
  severity: mysqlEnum("severity", ["critical", "high", "medium", "info"]).notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  body: text("body").notNull(),
  affectedProjectIds: json("affectedProjectIds"),
  affectedCategories: json("affectedCategories"),
  triggerData: json("triggerData"),
  suggestedAction: text("suggestedAction").notNull(),
  status: mysqlEnum("status", ["active", "acknowledged", "resolved", "expired"]).default("active").notNull(),
  acknowledgedBy: int("acknowledgedBy"),
  acknowledgedAt: timestamp("acknowledgedAt"),
  expiresAt: timestamp("expiresAt").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type PlatformAlert = typeof platformAlerts.$inferSelect;
export type InsertPlatformAlert = typeof platformAlerts.$inferInsert;

// ─── NL Query Log (V7 — Production Hardening) ───────────────────────────────
export const nlQueryLog = mysqlTable("nl_query_log", {
  id: int("id").primaryKey().autoincrement(),
  userId: int("user_id").notNull(),
  queryText: text("query_text").notNull(),
  sqlGenerated: text("sql_generated"),
  rowsReturned: int("rows_returned").default(0),
  executionMs: int("execution_ms"),
  status: mysqlEnum("status", ["success", "error", "blocked"]).default("success"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type NlQueryLog = typeof nlQueryLog.$inferSelect;
export type InsertNlQueryLog = typeof nlQueryLog.$inferInsert;

// ─── V8 - Design Intelligence Layer ───────────────────────────────────────
export const materialLibrary = mysqlTable("material_library", {
  id: int("id").primaryKey().autoincrement(),
  category: mysqlEnum("category", [
    "flooring", "wall_paint", "wall_tile", "ceiling",
    "joinery", "sanitaryware", "fittings", "lighting",
    "hardware", "specialty"
  ]).notNull(),
  tier: mysqlEnum("tier", [
    "affordable", "mid", "premium", "ultra"
  ]).notNull(),
  style: mysqlEnum("style", [
    "modern", "contemporary", "classic",
    "minimalist", "arabesque", "all"
  ]).default("all").notNull(),
  productCode: varchar("product_code", { length: 100 }),
  productName: varchar("product_name", { length: 300 }).notNull(),
  brand: varchar("brand", { length: 150 }).notNull(),
  supplierName: varchar("supplier_name", { length: 200 }).notNull(),
  supplierLocation: varchar("supplier_location", { length: 200 }),
  supplierPhone: varchar("supplier_phone", { length: 50 }),
  unitLabel: varchar("unit_label", { length: 30 }).notNull(),
  priceAedMin: decimal("price_aed_min", { precision: 10, scale: 2 }),
  priceAedMax: decimal("price_aed_max", { precision: 10, scale: 2 }),
  notes: text("notes"),
  isActive: boolean("is_active").default(true).notNull(),
});

export type MaterialLibrary = typeof materialLibrary.$inferSelect;
export type InsertMaterialLibrary = typeof materialLibrary.$inferInsert;

export const finishScheduleItems = mysqlTable(
  "finish_schedule_items", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  roomId: varchar("room_id", { length: 10 }).notNull(),
  roomName: varchar("room_name", { length: 100 }).notNull(),
  element: mysqlEnum("element", [
    "floor", "wall_primary", "wall_feature",
    "wall_wet", "ceiling", "joinery", "hardware"
  ]).notNull(),
  materialLibraryId: int("material_library_id"),
  overrideSpec: varchar("override_spec", { length: 500 }),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type FinishScheduleItem = typeof finishScheduleItems.$inferSelect;
export type InsertFinishScheduleItem = typeof finishScheduleItems.$inferInsert;

export const projectColorPalettes = mysqlTable(
  "project_color_palettes", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  paletteKey: varchar("palette_key", { length: 100 }).notNull(),
  colors: json("colors").notNull(),
  geminiRationale: text("gemini_rationale"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type ProjectColorPalette = typeof projectColorPalettes.$inferSelect;
export type InsertProjectColorPalette = typeof projectColorPalettes.$inferInsert;

export const rfqLineItems = mysqlTable("rfq_line_items", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  sectionNo: int("section_no").notNull(),
  itemCode: varchar("item_code", { length: 20 }).notNull(),
  description: varchar("description", { length: 500 }).notNull(),
  unit: varchar("unit", { length: 20 }).notNull(),
  quantity: decimal("quantity", { precision: 10, scale: 2 }),
  unitRateAedMin: decimal("unit_rate_aed_min",
    { precision: 10, scale: 2 }),
  unitRateAedMax: decimal("unit_rate_aed_max",
    { precision: 10, scale: 2 }),
  totalAedMin: decimal("total_aed_min",
    { precision: 12, scale: 2 }),
  totalAedMax: decimal("total_aed_max",
    { precision: 12, scale: 2 }),
  supplierName: varchar("supplier_name", { length: 200 }),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type RfqLineItem = typeof rfqLineItems.$inferSelect;
export type InsertRfqLineItem = typeof rfqLineItems.$inferInsert;

export const dmComplianceChecklists = mysqlTable(
  "dm_compliance_checklists", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  items: json("items").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type DmComplianceChecklist = typeof dmComplianceChecklists.$inferSelect;
export type InsertDmComplianceChecklist = typeof dmComplianceChecklists.$inferInsert;

// ─── V9 - Strategic Risk & Economic Modeling ────────────────────────────────

export const projectRoiModels = mysqlTable("project_roi_models", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  scenarioId: int("scenario_id"),
  reworkCostAvoided: decimal("rework_cost_avoided", { precision: 14, scale: 2 }).notNull(),
  programmeAccelerationValue: decimal("programme_acceleration_value", { precision: 14, scale: 2 }).notNull(),
  totalValueCreated: decimal("total_value_created", { precision: 14, scale: 2 }).notNull(),
  netRoiPercent: decimal("net_roi_percent", { precision: 8, scale: 2 }).notNull(),
  confidenceMultiplier: decimal("confidence_multiplier", { precision: 5, scale: 4 }).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type ProjectRoiModel = typeof projectRoiModels.$inferSelect;
export type InsertProjectRoiModel = typeof projectRoiModels.$inferInsert;

export const scenarioStressTests = mysqlTable("scenario_stress_tests", {
  id: int("id").primaryKey().autoincrement(),
  scenarioId: int("scenario_id").notNull(),
  stressCondition: varchar("stress_condition", { length: 100 }).notNull(),
  impactMagnitudePercent: decimal("impact_magnitude_percent", { precision: 6, scale: 2 }).notNull(),
  resilienceScore: int("resilience_score").notNull(), // 1-100
  failurePoints: json("failure_points").notNull(), // JSON array of components that fail
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type ScenarioStressTest = typeof scenarioStressTests.$inferSelect;
export type InsertScenarioStressTest = typeof scenarioStressTests.$inferInsert;

export const riskSurfaceMaps = mysqlTable("risk_surface_maps", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  domain: varchar("domain", { length: 100 }).notNull(),
  probability: int("probability").notNull(), // 0-100
  impact: int("impact").notNull(), // 0-100
  vulnerability: int("vulnerability").notNull(), // 0-100
  controlStrength: int("control_strength").notNull(), // 1-100
  compositeRiskScore: int("composite_risk_score").notNull(), // Calculated via R = (P * I * V) / C
  riskBand: mysqlEnum("risk_band", ["Minimal", "Controlled", "Elevated", "Critical", "Systemic"]).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type RiskSurfaceMap = typeof riskSurfaceMaps.$inferSelect;
export type InsertRiskSurfaceMap = typeof riskSurfaceMaps.$inferInsert;

===
import {
  int,
  mysqlEnum,
  mysqlTable,
  text,
  timestamp,
  varchar,
  decimal,
  boolean,
  json,
} from "drizzle-orm/mysql-core";

// ─── Users ───────────────────────────────────────────────────────────────────
export const users = mysqlTable("users", {
  id: int("id").autoincrement().primaryKey(),
  openId: varchar("openId", { length: 64 }).notNull().unique(),
  password: varchar("password", { length: 255 }),
  name: text("name"),
  email: varchar("email", { length: 320 }),
  loginMethod: varchar("loginMethod", { length: 64 }),
  role: mysqlEnum("role", ["user", "admin"]).default("user").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  lastSignedIn: timestamp("lastSignedIn").defaultNow().notNull(),
  orgId: int("orgId"), // added in V7 for backward compat later to be notNull
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;

// ─── Organizations (V7 - Multi-tenancy) ─────────────────────────────────────────────────────────
export const organizations = mysqlTable("organizations", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  slug: varchar("slug", { length: 255 }).notNull().unique(),
  domain: varchar("domain", { length: 255 }),
  plan: mysqlEnum("plan", ["free", "pro", "enterprise"]).default("free").notNull(),
  stripeCustomerId: varchar("stripeCustomerId", { length: 255 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Organization = typeof organizations.$inferSelect;
export type InsertOrganization = typeof organizations.$inferInsert;

export const organizationMembers = mysqlTable("organization_members", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId").notNull(),
  userId: int("userId").notNull(),
  role: mysqlEnum("role", ["admin", "member", "viewer"]).default("member").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type OrganizationMember = typeof organizationMembers.$inferSelect;
export type InsertOrganizationMember = typeof organizationMembers.$inferInsert;

export const organizationInvites = mysqlTable("organization_invites", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId").notNull(),
  email: varchar("email", { length: 320 }).notNull(),
  role: mysqlEnum("role", ["admin", "member", "viewer"]).default("member").notNull(),
  token: varchar("token", { length: 255 }).notNull().unique(),
  expiresAt: timestamp("expiresAt").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type OrganizationInvite = typeof organizationInvites.$inferSelect;
export type InsertOrganizationInvite = typeof organizationInvites.$inferInsert;


// ─── Model Versions ─────────────────────────────────────────────────────────
export const modelVersions = mysqlTable("model_versions", {
  id: int("id").autoincrement().primaryKey(),
  versionTag: varchar("versionTag", { length: 32 }).notNull().unique(),
  dimensionWeights: json("dimensionWeights").notNull(),
  variableWeights: json("variableWeights").notNull(),
  penaltyConfig: json("penaltyConfig").notNull(),
  isActive: boolean("isActive").default(false).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
  notes: text("notes"),
});

export type ModelVersion = typeof modelVersions.$inferSelect;
export type InsertModelVersion = typeof modelVersions.$inferInsert;

// ─── Benchmark Versions (V2) ───────────────────────────────────────────────
export const benchmarkVersions = mysqlTable("benchmark_versions", {
  id: int("id").autoincrement().primaryKey(),
  versionTag: varchar("versionTag", { length: 64 }).notNull().unique(),
  description: text("description"),
  status: mysqlEnum("status", ["draft", "published", "archived"]).default("draft").notNull(),
  publishedAt: timestamp("publishedAt"),
  publishedBy: int("publishedBy"),
  recordCount: int("recordCount").default(0),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
});

export type BenchmarkVersion = typeof benchmarkVersions.$inferSelect;
export type InsertBenchmarkVersion = typeof benchmarkVersions.$inferInsert;

// ─── Benchmark Categories (V2) ─────────────────────────────────────────────
export const benchmarkCategories = mysqlTable("benchmark_categories", {
  id: int("id").autoincrement().primaryKey(),
  category: mysqlEnum("category", [
    "materials",
    "finishes",
    "ffe",
    "procurement",
    "cost_bands",
    "tier_definitions",
    "style_families",
    "brand_archetypes",
    "risk_factors",
    "lead_times",
  ]).notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  market: varchar("market", { length: 64 }).default("UAE").notNull(),
  submarket: varchar("submarket", { length: 64 }).default("Dubai"),
  projectClass: mysqlEnum("projectClass", ["mid", "upper", "luxury", "ultra_luxury"]).notNull(),
  validFrom: timestamp("validFrom"),
  validTo: timestamp("validTo"),
  confidenceLevel: mysqlEnum("confidenceLevel", ["high", "medium", "low"]).default("medium"),
  sourceType: mysqlEnum("sourceType", ["manual", "admin", "imported", "curated"]).default("admin"),
  benchmarkVersionId: int("benchmarkVersionId"),
  data: json("data").notNull(),
  versionTag: varchar("versionTag", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  createdBy: int("createdBy"),
});

export type BenchmarkCategory = typeof benchmarkCategories.$inferSelect;
export type InsertBenchmarkCategory = typeof benchmarkCategories.$inferInsert;

// ─── Projects ────────────────────────────────────────────────────────────────
export const projects = mysqlTable("projects", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull(),
  orgId: int("orgId"),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  status: mysqlEnum("status", [
    "draft",
    "ready",
    "processing",
    "evaluated",
    "locked",
  ])
    .default("draft")
    .notNull(),

  // Approval gate (V2.8)
  approvalState: mysqlEnum("approvalState", [
    "draft",
    "review",
    "approved_rfq",
    "approved_marketing",
  ]).default("draft"),

  // Context variables
  ctx01Typology: mysqlEnum("ctx01Typology", [
    "Residential",
    "Mixed-use",
    "Hospitality",
    "Office",
  ]).default("Residential"),
  ctx02Scale: mysqlEnum("ctx02Scale", ["Small", "Medium", "Large"]).default(
    "Medium"
  ),
  ctx03Gfa: decimal("ctx03Gfa", { precision: 12, scale: 2 }),
  ctx04Location: mysqlEnum("ctx04Location", [
    "Prime",
    "Secondary",
    "Emerging",
  ]).default("Secondary"),
  ctx05Horizon: mysqlEnum("ctx05Horizon", [
    "0-12m",
    "12-24m",
    "24-36m",
    "36m+",
  ]).default("12-24m"),

  // Strategy variables (1-5)
  str01BrandClarity: int("str01BrandClarity").default(3),
  str02Differentiation: int("str02Differentiation").default(3),
  str03BuyerMaturity: int("str03BuyerMaturity").default(3),

  // Market variables
  mkt01Tier: mysqlEnum("mkt01Tier", [
    "Mid",
    "Upper-mid",
    "Luxury",
    "Ultra-luxury",
  ]).default("Upper-mid"),
  mkt02Competitor: int("mkt02Competitor").default(3),
  mkt03Trend: int("mkt03Trend").default(3),

  // Financial variables
  fin01BudgetCap: decimal("fin01BudgetCap", { precision: 10, scale: 2 }),
  fin02Flexibility: int("fin02Flexibility").default(3),
  fin03ShockTolerance: int("fin03ShockTolerance").default(3),
  fin04SalesPremium: int("fin04SalesPremium").default(3),

  // Design variables
  des01Style: mysqlEnum("des01Style", [
    "Modern",
    "Contemporary",
    "Minimal",
    "Classic",
    "Fusion",
    "Other",
  ]).default("Modern"),
  des02MaterialLevel: int("des02MaterialLevel").default(3),
  des03Complexity: int("des03Complexity").default(3),
  des04Experience: int("des04Experience").default(3),
  des05Sustainability: int("des05Sustainability").default(2),

  // Execution variables
  exe01SupplyChain: int("exe01SupplyChain").default(3),
  exe02Contractor: int("exe02Contractor").default(3),
  exe03Approvals: int("exe03Approvals").default(2),
  exe04QaMaturity: int("exe04QaMaturity").default(3),

  // Add-on variables
  add01SampleKit: boolean("add01SampleKit").default(false),
  add02PortfolioMode: boolean("add02PortfolioMode").default(false),
  add03DashboardExport: boolean("add03DashboardExport").default(true),

  modelVersionId: int("modelVersionId"),
  benchmarkVersionId: int("benchmarkVersionId"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  lockedAt: timestamp("lockedAt"),
});

export type Project = typeof projects.$inferSelect;
export type InsertProject = typeof projects.$inferInsert;

// ─── Direction Candidates ────────────────────────────────────────────────────
export const directionCandidates = mysqlTable("direction_candidates", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  isPrimary: boolean("isPrimary").default(false),
  des01Style: mysqlEnum("des01Style", [
    "Modern",
    "Contemporary",
    "Minimal",
    "Classic",
    "Fusion",
    "Other",
  ]),
  des02MaterialLevel: int("des02MaterialLevel"),
  des03Complexity: int("des03Complexity"),
  des04Experience: int("des04Experience"),
  fin01BudgetCap: decimal("fin01BudgetCap", { precision: 10, scale: 2 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type DirectionCandidate = typeof directionCandidates.$inferSelect;
export type InsertDirectionCandidate = typeof directionCandidates.$inferInsert;

// ─── Score Matrices ──────────────────────────────────────────────────────────
export const scoreMatrices = mysqlTable("score_matrices", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  directionId: int("directionId"),
  modelVersionId: int("modelVersionId").notNull(),
  benchmarkVersionId: int("benchmarkVersionId"),
  saScore: decimal("saScore", { precision: 6, scale: 2 }).notNull(),
  ffScore: decimal("ffScore", { precision: 6, scale: 2 }).notNull(),
  mpScore: decimal("mpScore", { precision: 6, scale: 2 }).notNull(),
  dsScore: decimal("dsScore", { precision: 6, scale: 2 }).notNull(),
  erScore: decimal("erScore", { precision: 6, scale: 2 }).notNull(),
  compositeScore: decimal("compositeScore", {
    precision: 6,
    scale: 2,
  }).notNull(),
  riskScore: decimal("riskScore", { precision: 6, scale: 2 }).notNull(),
  rasScore: decimal("rasScore", { precision: 6, scale: 2 }).notNull(),
  confidenceScore: decimal("confidenceScore", {
    precision: 6,
    scale: 2,
  }).notNull(),
  decisionStatus: mysqlEnum("decisionStatus", [
    "validated",
    "conditional",
    "not_validated",
  ]).notNull(),
  penalties: json("penalties"),
  riskFlags: json("riskFlags"),
  dimensionWeights: json("dimensionWeights").notNull(),
  variableContributions: json("variableContributions").notNull(),
  conditionalActions: json("conditionalActions"),
  inputSnapshot: json("inputSnapshot").notNull(),
  budgetFitMethod: varchar("budgetFitMethod", { length: 32 }),
  computedAt: timestamp("computedAt").defaultNow().notNull(),
});

export type ScoreMatrix = typeof scoreMatrices.$inferSelect;
export type InsertScoreMatrix = typeof scoreMatrices.$inferInsert;

// ─── Scenarios ───────────────────────────────────────────────────────────────
export const scenarios = mysqlTable("scenarios", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  orgId: int("orgId"),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  variableOverrides: json("variableOverrides"),
  isTemplate: boolean("isTemplate").default(false),
  templateKey: varchar("templateKey", { length: 64 }),
  scoreMatrixId: int("scoreMatrixId"),
  rasScore: decimal("rasScore", { precision: 6, scale: 2 }),
  isDominant: boolean("isDominant").default(false),
  stabilityScore: decimal("stabilityScore", { precision: 6, scale: 2 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Scenario = typeof scenarios.$inferSelect;
export type InsertScenario = typeof scenarios.$inferInsert;

// ─── Benchmark Data (Expanded) ──────────────────────────────────────────────
export const benchmarkData = mysqlTable("benchmark_data", {
  id: int("id").autoincrement().primaryKey(),
  typology: varchar("typology", { length: 64 }).notNull(),
  location: varchar("location", { length: 64 }).notNull(),
  marketTier: varchar("marketTier", { length: 64 }).notNull(),
  materialLevel: int("materialLevel").notNull(),
  roomType: varchar("roomType", { length: 64 }).default("General"),
  costPerSqftLow: decimal("costPerSqftLow", { precision: 10, scale: 2 }),
  costPerSqftMid: decimal("costPerSqftMid", { precision: 10, scale: 2 }),
  costPerSqftHigh: decimal("costPerSqftHigh", { precision: 10, scale: 2 }),
  avgSellingPrice: decimal("avgSellingPrice", { precision: 10, scale: 2 }),
  absorptionRate: decimal("absorptionRate", { precision: 6, scale: 4 }),
  competitiveDensity: int("competitiveDensity"),
  differentiationIndex: decimal("differentiationIndex", { precision: 6, scale: 4 }),
  complexityMultiplier: decimal("complexityMultiplier", { precision: 6, scale: 4 }),
  timelineRiskMultiplier: decimal("timelineRiskMultiplier", { precision: 6, scale: 4 }),
  buyerPreferenceWeights: json("buyerPreferenceWeights"),
  sourceType: mysqlEnum("sourceType", [
    "synthetic",
    "client_provided",
    "curated",
  ]).default("synthetic"),
  sourceNote: text("sourceNote"),
  dataYear: int("dataYear"),
  region: varchar("region", { length: 64 }).default("UAE"),
  benchmarkVersionId: int("benchmarkVersionId"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type BenchmarkData = typeof benchmarkData.$inferSelect;
export type InsertBenchmarkData = typeof benchmarkData.$inferInsert;

// ─── Project Intelligence Warehouse (V2) ───────────────────────────────────
export const projectIntelligence = mysqlTable("project_intelligence", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scoreMatrixId: int("scoreMatrixId").notNull(),
  benchmarkVersionId: int("benchmarkVersionId"),
  modelVersionId: int("modelVersionId"),
  costDeltaVsBenchmark: decimal("costDeltaVsBenchmark", { precision: 10, scale: 2 }),
  uniquenessIndex: decimal("uniquenessIndex", { precision: 6, scale: 4 }),
  feasibilityFlags: json("feasibilityFlags"),
  reworkRiskIndex: decimal("reworkRiskIndex", { precision: 6, scale: 4 }),
  procurementComplexity: decimal("procurementComplexity", { precision: 6, scale: 4 }),
  tierPercentile: decimal("tierPercentile", { precision: 6, scale: 4 }),
  styleFamily: varchar("styleFamily", { length: 64 }),
  costBand: varchar("costBand", { length: 32 }),
  inputSnapshot: json("inputSnapshot"),
  scoreSnapshot: json("scoreSnapshot"),
  computedAt: timestamp("computedAt").defaultNow().notNull(),
});

export type ProjectIntelligence = typeof projectIntelligence.$inferSelect;
export type InsertProjectIntelligence = typeof projectIntelligence.$inferInsert;

// ─── Report Instances ────────────────────────────────────────────────────────
export const reportInstances = mysqlTable("report_instances", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scoreMatrixId: int("scoreMatrixId").notNull(),
  reportType: mysqlEnum("reportType", [
    "executive_pack",
    "full_technical",
    "tender_brief",
    "executive_decision_pack",
    "design_brief_rfq",
    "marketing_starter",
    "validation_summary",
    "design_brief",
    "rfq_pack",
    "full_report",
    "marketing_prelaunch",
  ]).notNull(),
  fileUrl: text("fileUrl"),
  bundleUrl: text("bundleUrl"),
  content: json("content"),
  benchmarkVersionId: int("benchmarkVersionId"),
  modelVersionId: int("modelVersionId"),
  generatedAt: timestamp("generatedAt").defaultNow().notNull(),
  generatedBy: int("generatedBy"),
});

export type ReportInstance = typeof reportInstances.$inferSelect;
export type InsertReportInstance = typeof reportInstances.$inferInsert;

// ─── ROI Configurations (V2) ───────────────────────────────────────────────
export const roiConfigs = mysqlTable("roi_configs", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 128 }).notNull(),
  isActive: boolean("isActive").default(false).notNull(),
  hourlyRate: decimal("hourlyRate", { precision: 10, scale: 2 }).default("350").notNull(),
  reworkCostPct: decimal("reworkCostPct", { precision: 6, scale: 4 }).default("0.12").notNull(),
  tenderIterationCost: decimal("tenderIterationCost", { precision: 10, scale: 2 }).default("25000").notNull(),
  designCycleCost: decimal("designCycleCost", { precision: 10, scale: 2 }).default("45000").notNull(),
  budgetVarianceMultiplier: decimal("budgetVarianceMultiplier", { precision: 6, scale: 4 }).default("0.08").notNull(),
  timeAccelerationWeeks: int("timeAccelerationWeeks").default(6),
  conservativeMultiplier: decimal("conservativeMultiplier", { precision: 6, scale: 4 }).default("0.60").notNull(),
  aggressiveMultiplier: decimal("aggressiveMultiplier", { precision: 6, scale: 4 }).default("1.40").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
});

export type RoiConfig = typeof roiConfigs.$inferSelect;
export type InsertRoiConfig = typeof roiConfigs.$inferInsert;

// ─── Webhook Configurations (V2) ───────────────────────────────────────────
export const webhookConfigs = mysqlTable("webhook_configs", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  url: text("url").notNull(),
  secret: varchar("secret", { length: 255 }),
  events: json("events").notNull(),
  fieldMapping: json("fieldMapping"),
  isActive: boolean("isActive").default(true).notNull(),
  lastTriggeredAt: timestamp("lastTriggeredAt"),
  lastStatus: int("lastStatus"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  createdBy: int("createdBy"),
});

export type WebhookConfig = typeof webhookConfigs.$inferSelect;
export type InsertWebhookConfig = typeof webhookConfigs.$inferInsert;

// ─── Project Assets (V2.8 — Evidence Vault) ────────────────────────────────
export const projectAssets = mysqlTable("project_assets", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  filename: varchar("filename", { length: 512 }).notNull(),
  mimeType: varchar("mimeType", { length: 128 }).notNull(),
  sizeBytes: int("sizeBytes").notNull(),
  storagePath: text("storagePath").notNull(),
  storageUrl: text("storageUrl"),
  checksum: varchar("checksum", { length: 128 }),
  uploadedBy: int("uploadedBy").notNull(),
  category: mysqlEnum("category", [
    "brief",
    "brand",
    "budget",
    "competitor",
    "inspiration",
    "material",
    "sales",
    "legal",
    "mood_image",
    "material_board",
    "marketing_hero",
    "generated",
    "other",
  ]).default("other").notNull(),
  tags: json("tags"), // string[]
  notes: text("notes"),
  isClientVisible: boolean("isClientVisible").default(true).notNull(),
  uploadedAt: timestamp("uploadedAt").defaultNow().notNull(),
});

export type ProjectAsset = typeof projectAssets.$inferSelect;
export type InsertProjectAsset = typeof projectAssets.$inferInsert;

// ─── Asset Links (V2.8 — Evidence Traceability) ────────────────────────────
export const assetLinks = mysqlTable("asset_links", {
  id: int("id").autoincrement().primaryKey(),
  assetId: int("assetId").notNull(),
  linkType: mysqlEnum("linkType", [
    "evaluation",
    "report",
    "scenario",
    "material_board",
    "design_brief",
    "visual",
  ]).notNull(),
  linkId: int("linkId").notNull(), // ID of the linked entity
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type AssetLink = typeof assetLinks.$inferSelect;
export type InsertAssetLink = typeof assetLinks.$inferInsert;

// ─── Design Briefs (V2.8 — Design Direction Generator) ─────────────────────
export const designBriefs = mysqlTable("design_briefs", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scenarioId: int("scenarioId"), // optional: brief for a specific scenario
  version: int("version").default(1).notNull(),
  // 7 sections as JSON
  projectIdentity: json("projectIdentity").notNull(),
  positioningStatement: text("positioningStatement").notNull(),
  styleMood: json("styleMood").notNull(),
  materialGuidance: json("materialGuidance").notNull(),
  budgetGuardrails: json("budgetGuardrails").notNull(),
  procurementConstraints: json("procurementConstraints").notNull(),
  deliverablesChecklist: json("deliverablesChecklist").notNull(),
  // Metadata
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type DesignBrief = typeof designBriefs.$inferSelect;
export type InsertDesignBrief = typeof designBriefs.$inferInsert;

// ─── Generated Visuals (V2.8 — nano banana) ────────────────────────────────
export const generatedVisuals = mysqlTable("generated_visuals", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scenarioId: int("scenarioId"),
  type: mysqlEnum("type", ["mood", "mood_board", "material_board", "room_render", "kitchen_render", "bathroom_render", "color_palette", "hero"]).notNull(),
  promptJson: json("promptJson").notNull(),
  modelVersion: varchar("modelVersion", { length: 64 }).default("nano-banana-v1"),
  imageAssetId: int("imageAssetId"), // FK to project_assets
  status: mysqlEnum("status", ["pending", "generating", "completed", "failed"]).default("pending").notNull(),
  errorMessage: text("errorMessage"),
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type GeneratedVisual = typeof generatedVisuals.$inferSelect;
export type InsertGeneratedVisual = typeof generatedVisuals.$inferInsert;

// ─── Design Trends (V3 — Phase 3 Trend Detection) ───────────────────────────
export const designTrends = mysqlTable("design_trends", {
  id: int("id").autoincrement().primaryKey(),
  trendName: varchar("trendName", { length: 255 }).notNull(),
  trendCategory: mysqlEnum("trendCategory", [
    "style", "material", "color", "layout", "technology", "sustainability", "other",
  ]).notNull(),
  confidenceLevel: mysqlEnum("confidenceLevel", ["emerging", "established", "declining"]).default("emerging").notNull(),
  sourceUrl: text("sourceUrl"),
  sourceRegistryId: int("sourceRegistryId"),
  description: text("description"),
  relatedMaterials: json("relatedMaterials"), // string[] of material names
  styleClassification: varchar("styleClassification", { length: 128 }), // modern, classical, biophilic, japandi, etc.
  region: varchar("region", { length: 64 }).default("UAE"),
  firstSeenAt: timestamp("firstSeenAt").defaultNow().notNull(),
  lastSeenAt: timestamp("lastSeenAt").defaultNow().notNull(),
  mentionCount: int("mentionCount").default(1).notNull(),
  runId: varchar("runId", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type DesignTrend = typeof designTrends.$inferSelect;
export type InsertDesignTrend = typeof designTrends.$inferInsert;

// ─── Material Boards (V2.8 — Board Composer) ────────────────────────────────
export const materialBoards = mysqlTable("material_boards", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  scenarioId: int("scenarioId"),
  boardName: varchar("boardName", { length: 255 }).notNull(),
  boardJson: json("boardJson").notNull(), // materials/finishes/ff&e items
  boardImageAssetId: int("boardImageAssetId"), // FK to project_assets
  benchmarkVersionId: int("benchmarkVersionId"),
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type MaterialBoard = typeof materialBoards.$inferSelect;
export type InsertMaterialBoard = typeof materialBoards.$inferInsert;

// ─── Materials Catalog (V2.8 — FF&E Library) ────────────────────────────────
export const materialsCatalog = mysqlTable("materials_catalog", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  category: mysqlEnum("category", [
    "tile",
    "stone",
    "wood",
    "metal",
    "fabric",
    "glass",
    "paint",
    "wallpaper",
    "lighting",
    "furniture",
    "fixture",
    "accessory",
    "other",
  ]).notNull(),
  tier: mysqlEnum("tier", ["economy", "mid", "premium", "luxury", "ultra_luxury"]).notNull(),
  typicalCostLow: decimal("typicalCostLow", { precision: 10, scale: 2 }),
  typicalCostHigh: decimal("typicalCostHigh", { precision: 10, scale: 2 }),
  costUnit: varchar("costUnit", { length: 32 }).default("AED/sqm"),
  leadTimeDays: int("leadTimeDays"),
  leadTimeBand: mysqlEnum("leadTimeBand", ["short", "medium", "long", "critical"]).default("medium"),
  regionAvailability: json("regionAvailability"), // string[]
  supplierName: varchar("supplierName", { length: 255 }),
  supplierContact: varchar("supplierContact", { length: 255 }),
  supplierUrl: text("supplierUrl"),
  imageUrl: text("imageUrl"),
  notes: text("notes"),
  isActive: boolean("isActive").default(true).notNull(),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type MaterialCatalogItem = typeof materialsCatalog.$inferSelect;
export type InsertMaterialCatalogItem = typeof materialsCatalog.$inferInsert;

// ─── Materials to Boards (V2.8 — Join Table) ────────────────────────────────
export const materialsToBoards = mysqlTable("materials_to_boards", {
  id: int("id").autoincrement().primaryKey(),
  boardId: int("boardId").notNull(),
  materialId: int("materialId").notNull(),
  quantity: decimal("quantity", { precision: 10, scale: 2 }),
  unitOfMeasure: varchar("unitOfMeasure", { length: 32 }),
  notes: text("notes"),
  sortOrder: int("sortOrder").default(0).notNull(),
  specNotes: text("specNotes"),
  costBandOverride: varchar("costBandOverride", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type MaterialToBoard = typeof materialsToBoards.$inferSelect;
export type InsertMaterialToBoard = typeof materialsToBoards.$inferInsert;

// ─── Prompt Templates (V2.8 — Admin-editable nano banana prompts) ───────────
export const promptTemplates = mysqlTable("prompt_templates", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId"),
  name: varchar("name", { length: 255 }).notNull(),
  type: mysqlEnum("type", ["mood", "material_board", "hero"]).notNull(),
  templateText: text("templateText").notNull(),
  variables: json("variables").notNull(), // string[] of variable names
  isActive: boolean("isActive").default(true).notNull(),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type PromptTemplate = typeof promptTemplates.$inferSelect;
export type InsertPromptTemplate = typeof promptTemplates.$inferInsert;

// ─── Comments (V2.8 — Collaboration) ────────────────────────────────────────
export const comments = mysqlTable("comments", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  entityType: mysqlEnum("entityType", [
    "design_brief",
    "material_board",
    "visual",
    "general",
  ]).notNull(),
  entityId: int("entityId"),
  userId: int("userId").notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Comment = typeof comments.$inferSelect;
export type InsertComment = typeof comments.$inferInsert;

// ─── Audit Logs ──────────────────────────────────────────────────────────────
export const auditLogs = mysqlTable("audit_logs", {
  id: int("id").autoincrement().primaryKey(),
  orgId: int("orgId"),
  userId: int("userId"),
  action: varchar("action", { length: 128 }).notNull(),
  entityType: varchar("entityType", { length: 64 }).notNull(),
  entityId: int("entityId"),
  details: json("details"),
  benchmarkVersionId: int("benchmarkVersionId"),
  modelVersionId: int("modelVersionId"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  ipAddress: varchar("ipAddress", { length: 64 }),
});

export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertAuditLog = typeof auditLogs.$inferInsert;

// ─── Override Records ────────────────────────────────────────────────────────
export const overrideRecords = mysqlTable("override_records", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  userId: int("userId").notNull(),
  overrideType: mysqlEnum("overrideType", [
    "strategic",
    "market_insight",
    "risk_adjustment",
    "experimental",
  ]).notNull(),
  authorityLevel: int("authorityLevel").notNull(),
  originalValue: json("originalValue").notNull(),
  overrideValue: json("overrideValue").notNull(),
  justification: text("justification").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type OverrideRecord = typeof overrideRecords.$inferSelect;
export type InsertOverrideRecord = typeof overrideRecords.$inferInsert;

// ─── Logic Versions (V2.10 — Logic/Policy Registry) ──────────────────────────
export const logicVersions = mysqlTable("logic_versions", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 128 }).notNull(),
  status: mysqlEnum("status", ["draft", "published", "archived"]).default("draft").notNull(),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  publishedAt: timestamp("publishedAt"),
  notes: text("notes"),
});

export type LogicVersion = typeof logicVersions.$inferSelect;
export type InsertLogicVersion = typeof logicVersions.$inferInsert;

// ─── Logic Weights (V2.10) ───────────────────────────────────────────────────
export const logicWeights = mysqlTable("logic_weights", {
  id: int("id").autoincrement().primaryKey(),
  logicVersionId: int("logicVersionId").notNull(),
  dimension: varchar("dimension", { length: 32 }).notNull(), // sa, ff, mp, ds, er
  weight: decimal("weight", { precision: 6, scale: 4 }).notNull(),
});

export type LogicWeight = typeof logicWeights.$inferSelect;
export type InsertLogicWeight = typeof logicWeights.$inferInsert;

// ─── Logic Thresholds (V2.10) ────────────────────────────────────────────────
export const logicThresholds = mysqlTable("logic_thresholds", {
  id: int("id").autoincrement().primaryKey(),
  logicVersionId: int("logicVersionId").notNull(),
  ruleKey: varchar("ruleKey", { length: 128 }).notNull(),
  thresholdValue: decimal("thresholdValue", { precision: 10, scale: 4 }).notNull(),
  comparator: mysqlEnum("comparator", ["gt", "gte", "lt", "lte", "eq", "neq"]).notNull(),
  notes: text("notes"),
});

export type LogicThreshold = typeof logicThresholds.$inferSelect;
export type InsertLogicThreshold = typeof logicThresholds.$inferInsert;

// ─── Logic Change Log (V2.10) ────────────────────────────────────────────────
export const logicChangeLog = mysqlTable("logic_change_log", {
  id: int("id").autoincrement().primaryKey(),
  logicVersionId: int("logicVersionId").notNull(),
  actor: int("actor").notNull(),
  changeSummary: text("changeSummary").notNull(),
  rationale: text("rationale").notNull(),
  status: mysqlEnum("status", ["applied", "proposed", "rejected"]).default("applied").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type LogicChangeLogEntry = typeof logicChangeLog.$inferSelect;
export type InsertLogicChangeLogEntry = typeof logicChangeLog.$inferInsert;

// ─── Pattern Library (V5-07) ──────────────────────────────────────────────────
export const decisionPatterns = mysqlTable("decision_patterns", {
  id: int("id").autoincrement().primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  category: mysqlEnum("category", ["risk_indicator", "success_driver", "cost_anomaly"]).notNull(),
  conditions: json("conditions").notNull(), // array of logic defining the pattern
  matchCount: int("matchCount").default(0).notNull(), // times it appeared
  reliabilityScore: decimal("reliabilityScore", { precision: 5, scale: 2 }).default("0.00").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type DecisionPattern = typeof decisionPatterns.$inferSelect;
export type InsertDecisionPattern = typeof decisionPatterns.$inferInsert;

export const projectPatternMatches = mysqlTable("project_pattern_matches", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  patternId: int("patternId").notNull(),
  matchedAt: timestamp("matchedAt").defaultNow().notNull(),
  confidence: decimal("confidence", { precision: 5, scale: 2 }).default("1.00").notNull(),
  contextSnapshot: json("contextSnapshot"), // snapshot of scores during match
});

export type ProjectPatternMatch = typeof projectPatternMatches.$inferSelect;
export type InsertProjectPatternMatch = typeof projectPatternMatches.$inferInsert;


// ─── Scenario Inputs (V2.11) ─────────────────────────────────────────────────
export const scenarioInputs = mysqlTable("scenario_inputs", {
  id: int("id").autoincrement().primaryKey(),
  scenarioId: int("scenarioId").notNull(),
  jsonInput: json("jsonInput").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ScenarioInput = typeof scenarioInputs.$inferSelect;
export type InsertScenarioInput = typeof scenarioInputs.$inferInsert;

// ─── Scenario Outputs (V2.11) ────────────────────────────────────────────────
export const scenarioOutputs = mysqlTable("scenario_outputs", {
  id: int("id").autoincrement().primaryKey(),
  scenarioId: int("scenarioId").notNull(),
  scoreJson: json("scoreJson").notNull(),
  roiJson: json("roiJson"),
  riskJson: json("riskJson"),
  boardCostJson: json("boardCostJson"),
  benchmarkVersionId: int("benchmarkVersionId"),
  logicVersionId: int("logicVersionId"),
  computedAt: timestamp("computedAt").defaultNow().notNull(),
});

export type ScenarioOutput = typeof scenarioOutputs.$inferSelect;
export type InsertScenarioOutput = typeof scenarioOutputs.$inferInsert;

// ─── Scenario Comparisons (V2.11) ────────────────────────────────────────────
export const scenarioComparisons = mysqlTable("scenario_comparisons", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  baselineScenarioId: int("baselineScenarioId").notNull(),
  comparedScenarioIds: json("comparedScenarioIds").notNull(), // number[]
  decisionNote: text("decisionNote"),
  comparisonResult: json("comparisonResult"), // computed tradeoffs
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ScenarioComparison = typeof scenarioComparisons.$inferSelect;
export type InsertScenarioComparison = typeof scenarioComparisons.$inferInsert;

// ─── Project Outcomes (V2.13) ────────────────────────────────────────────────
export const projectOutcomes = mysqlTable("project_outcomes", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  procurementActualCosts: json("procurementActualCosts"),
  leadTimesActual: json("leadTimesActual"),
  rfqResults: json("rfqResults"),
  adoptionMetrics: json("adoptionMetrics"),

  // V5 Fields
  actualFitoutCostPerSqm: decimal("actualFitoutCostPerSqm", { precision: 10, scale: 2 }),
  actualTotalCost: decimal("actualTotalCost", { precision: 15, scale: 2 }),
  projectDeliveredOnTime: boolean("projectDeliveredOnTime"),
  reworkOccurred: boolean("reworkOccurred"),
  reworkCostAed: decimal("reworkCostAed", { precision: 15, scale: 2 }),
  clientSatisfactionScore: int("clientSatisfactionScore"),
  tenderIterations: int("tenderIterations"),
  keyLessonsLearned: text("keyLessonsLearned"),

  capturedAt: timestamp("capturedAt").defaultNow().notNull(),
  capturedBy: int("capturedBy"),
});

export type ProjectOutcome = typeof projectOutcomes.$inferSelect;
export type InsertProjectOutcome = typeof projectOutcomes.$inferInsert;

export const outcomeComparisons = mysqlTable("outcome_comparisons", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull(),
  comparedAt: timestamp("comparedAt").defaultNow().notNull(),

  // Cost accuracy
  predictedCostMid: decimal("predictedCostMid", { precision: 15, scale: 2 }),
  actualCost: decimal("actualCost", { precision: 15, scale: 2 }),
  costDeltaPct: decimal("costDeltaPct", { precision: 10, scale: 4 }),
  costAccuracyBand: mysqlEnum("costAccuracyBand", ["within_10pct", "within_20pct", "outside_20pct", "no_prediction"]).notNull(),

  // Score accuracy
  predictedComposite: decimal("predictedComposite", { precision: 5, scale: 4 }).notNull(),
  predictedDecision: varchar("predictedDecision", { length: 64 }).notNull(),
  actualOutcomeSuccess: boolean("actualOutcomeSuccess").notNull(),
  scorePredictionCorrect: boolean("scorePredictionCorrect").notNull(),

  // Risk accuracy
  predictedRisk: decimal("predictedRisk", { precision: 5, scale: 4 }).notNull(),
  actualReworkOccurred: boolean("actualReworkOccurred").notNull(),
  riskPredictionCorrect: boolean("riskPredictionCorrect").notNull(),

  // Delta summary
  overallAccuracyGrade: mysqlEnum("overallAccuracyGrade", ["A", "B", "C", "insufficient_data"]).notNull(),
  learningSignals: json("learningSignals"),
  rawComparison: json("rawComparison"),
});

export type OutcomeComparison = typeof outcomeComparisons.$inferSelect;
export type InsertOutcomeComparison = typeof outcomeComparisons.$inferInsert;

export const accuracySnapshots = mysqlTable("accuracy_snapshots", {
  id: int("id").autoincrement().primaryKey(),
  snapshotDate: timestamp("snapshotDate").defaultNow().notNull(),

  totalComparisons: int("totalComparisons").notNull(),
  withCostPrediction: int("withCostPrediction").notNull(),
  withOutcomePrediction: int("withOutcomePrediction").notNull(),

  // Cost accuracy
  costWithin10Pct: int("costWithin10Pct").notNull(),
  costWithin20Pct: int("costWithin20Pct").notNull(),
  costOutside20Pct: int("costOutside20Pct").notNull(),
  costMaePct: decimal("costMaePct", { precision: 8, scale: 4 }),
  costTrend: mysqlEnum("costTrend", ["improving", "stable", "degrading", "insufficient_data"]).notNull(),

  // Score accuracy
  scoreCorrectPredictions: int("scoreCorrectPredictions").notNull(),
  scoreIncorrectPredictions: int("scoreIncorrectPredictions").notNull(),
  scoreAccuracyRate: decimal("scoreAccuracyRate", { precision: 8, scale: 4 }).notNull(),
  scoreTrend: mysqlEnum("scoreTrend", ["improving", "stable", "degrading", "insufficient_data"]).notNull(),

  // Risk accuracy
  riskCorrectPredictions: int("riskCorrectPredictions").notNull(),
  riskIncorrectPredictions: int("riskIncorrectPredictions").notNull(),
  riskAccuracyRate: decimal("riskAccuracyRate", { precision: 8, scale: 4 }).notNull(),
  riskTrend: mysqlEnum("riskTrend", ["improving", "stable", "degrading", "insufficient_data"]).notNull(),

  overallPlatformAccuracy: decimal("overallPlatformAccuracy", { precision: 8, scale: 4 }).notNull(),
  gradeA: int("gradeA").notNull(),
  gradeB: int("gradeB").notNull(),
  gradeC: int("gradeC").notNull(),
});

export type AccuracySnapshot = typeof accuracySnapshots.$inferSelect;
export type InsertAccuracySnapshot = typeof accuracySnapshots.$inferInsert;

// ─── Benchmark Suggestions (V2.13) ──────────────────────────────────────────
export const benchmarkSuggestions = mysqlTable("benchmark_suggestions", {
  id: int("id").autoincrement().primaryKey(),
  basedOnOutcomesQuery: text("basedOnOutcomesQuery"),
  suggestedChanges: json("suggestedChanges").notNull(),
  confidence: decimal("confidence", { precision: 6, scale: 4 }),
  status: mysqlEnum("status", ["pending", "accepted", "rejected"]).default("pending").notNull(),
  reviewerNotes: text("reviewerNotes"),
  reviewedBy: int("reviewedBy"),
  reviewedAt: timestamp("reviewedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type BenchmarkSuggestion = typeof benchmarkSuggestions.$inferSelect;
export type InsertBenchmarkSuggestion = typeof benchmarkSuggestions.$inferInsert;

// ═══════════════════════════════════════════════════════════════════════════════
// Stage 1 — Market Intelligence Layer V1
// ═══════════════════════════════════════════════════════════════════════════════

// ─── Source Registry (Stage 1) ──────────────────────────────────────────────
export const sourceRegistry = mysqlTable("source_registry", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  url: text("url").notNull(),
  sourceType: mysqlEnum("sourceType", [
    "supplier_catalog",
    "manufacturer_catalog",
    "developer_brochure",
    "industry_report",
    "government_tender",
    "procurement_portal",
    "trade_publication",
    "retailer_listing",
    "aggregator",
    "other",
  ]).notNull(),
  reliabilityDefault: mysqlEnum("reliabilityDefault", ["A", "B", "C"]).default("B").notNull(),
  isWhitelisted: boolean("isWhitelisted").default(true).notNull(),
  region: varchar("region", { length: 64 }).default("UAE"),
  notes: text("notes"),
  addedBy: int("addedBy"),
  isActive: boolean("isActive").default(true).notNull(),
  lastSuccessfulFetch: timestamp("lastSuccessfulFetch"),

  // DFE Fields
  scrapeConfig: json("scrapeConfig"),
  scrapeSchedule: varchar("scrapeSchedule", { length: 64 }),
  scrapeMethod: mysqlEnum("scrapeMethod", [
    "html_llm",
    "html_rules",
    "json_api",
    "rss_feed",
    "csv_upload",
    "email_forward",
  ]).default("html_llm").notNull(),
  scrapeHeaders: json("scrapeHeaders"),
  extractionHints: text("extractionHints"),
  priceFieldMapping: json("priceFieldMapping"),
  lastScrapedAt: timestamp("lastScrapedAt"),
  lastScrapedStatus: mysqlEnum("lastScrapedStatus", ["success", "partial", "failed", "never"]).default("never").notNull(),
  lastRecordCount: int("lastRecordCount").default(0).notNull(),
  consecutiveFailures: int("consecutiveFailures").default(0).notNull(),
  requestDelayMs: int("requestDelayMs").default(2000).notNull(),

  addedAt: timestamp("addedAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type SourceRegistryEntry = typeof sourceRegistry.$inferSelect;
export type InsertSourceRegistryEntry = typeof sourceRegistry.$inferInsert;

// ─── Evidence Records (Stage 1) ─────────────────────────────────────────────
export const evidenceRecords = mysqlTable("evidence_records", {
  id: int("id").autoincrement().primaryKey(),
  recordId: varchar("recordId", { length: 64 }).notNull().unique(), // MYR-PE-XXXX
  projectId: int("projectId"), // optional: can be global evidence
  orgId: int("orgId"),
  sourceRegistryId: int("sourceRegistryId"), // FK to source_registry
  category: mysqlEnum("category", [
    "floors",
    "walls",
    "ceilings",
    "joinery",
    "lighting",
    "sanitary",
    "kitchen",
    "hardware",
    "ffe",
    "other",
  ]).notNull(),
  itemName: varchar("itemName", { length: 255 }).notNull(),
  specClass: varchar("specClass", { length: 128 }),
  priceMin: decimal("priceMin", { precision: 12, scale: 2 }),
  priceTypical: decimal("priceTypical", { precision: 12, scale: 2 }),
  priceMax: decimal("priceMax", { precision: 12, scale: 2 }),
  unit: varchar("unit", { length: 32 }).notNull(), // sqm, lm, set, piece, etc.
  currencyOriginal: varchar("currencyOriginal", { length: 8 }).default("AED"),
  currencyAed: decimal("currencyAed", { precision: 12, scale: 2 }), // normalized to AED
  fxRate: decimal("fxRate", { precision: 10, scale: 6 }),
  fxSource: text("fxSource"),
  sourceUrl: text("sourceUrl").notNull(),
  publisher: varchar("publisher", { length: 255 }),
  captureDate: timestamp("captureDate").notNull(),
  reliabilityGrade: mysqlEnum("reliabilityGrade", ["A", "B", "C"]).notNull(),
  confidenceScore: int("confidenceScore").notNull(), // 0-100
  extractedSnippet: text("extractedSnippet"),
  notes: text("notes"),
  // V2.2 metadata fields
  title: varchar("title", { length: 512 }),
  evidencePhase: mysqlEnum("evidencePhase", ["concept", "schematic", "detailed_design", "tender", "procurement", "construction", "handover"]),
  author: varchar("author", { length: 255 }),
  confidentiality: mysqlEnum("confidentiality", ["public", "internal", "confidential", "restricted"]).default("internal"),
  tags: json("tags"), // string[]
  fileUrl: text("fileUrl"), // S3 signed URL for attached evidence file
  fileKey: varchar("fileKey", { length: 512 }), // S3 key for the file
  fileMimeType: varchar("fileMimeType", { length: 128 }),
  runId: varchar("runId", { length: 64 }), // links to intelligence_audit_log
  // V7: Design Intelligence Fields
  finishLevel: mysqlEnum("finishLevel", ["basic", "standard", "premium", "luxury", "ultra_luxury"]),
  designStyle: varchar("designStyle", { length: 255 }),
  brandsMentioned: json("brandsMentioned"), // string[]
  materialSpec: text("materialSpec"),
  intelligenceType: mysqlEnum("intelligenceType", [
    "material_price", "finish_specification", "design_trend",
    "market_statistic", "competitor_positioning", "regulation",
  ]).default("material_price"),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type EvidenceRecord = typeof evidenceRecords.$inferSelect;
export type InsertEvidenceRecord = typeof evidenceRecords.$inferInsert;

// ─── Benchmark Proposals (Stage 1) ──────────────────────────────────────────
export const benchmarkProposals = mysqlTable("benchmark_proposals", {
  id: int("id").autoincrement().primaryKey(),
  benchmarkKey: varchar("benchmarkKey", { length: 255 }).notNull(), // category:tier:unit
  currentTypical: decimal("currentTypical", { precision: 12, scale: 2 }),
  currentMin: decimal("currentMin", { precision: 12, scale: 2 }),
  currentMax: decimal("currentMax", { precision: 12, scale: 2 }),
  proposedP25: decimal("proposedP25", { precision: 12, scale: 2 }).notNull(),
  proposedP50: decimal("proposedP50", { precision: 12, scale: 2 }).notNull(),
  proposedP75: decimal("proposedP75", { precision: 12, scale: 2 }).notNull(),
  weightedMean: decimal("weightedMean", { precision: 12, scale: 2 }).notNull(),
  deltaPct: decimal("deltaPct", { precision: 8, scale: 2 }), // % change from current
  evidenceCount: int("evidenceCount").notNull(),
  sourceDiversity: int("sourceDiversity").notNull(),
  reliabilityDist: json("reliabilityDist").notNull(), // { A: n, B: n, C: n }
  recencyDist: json("recencyDist").notNull(), // { recent: n, mid: n, old: n }
  confidenceScore: int("confidenceScore").notNull(), // 0-100
  impactNotes: text("impactNotes"),
  recommendation: mysqlEnum("recommendation", ["publish", "reject"]).notNull(),
  rejectionReason: text("rejectionReason"),
  // Review workflow
  status: mysqlEnum("status", ["pending", "approved", "rejected"]).default("pending").notNull(),
  reviewerNotes: text("reviewerNotes"),
  reviewedBy: int("reviewedBy"),
  reviewedAt: timestamp("reviewedAt"),
  // Snapshot linking
  benchmarkSnapshotId: int("benchmarkSnapshotId"),
  runId: varchar("runId", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type BenchmarkProposal = typeof benchmarkProposals.$inferSelect;
export type InsertBenchmarkProposal = typeof benchmarkProposals.$inferInsert;

// ─── Benchmark Snapshots (Stage 1) ──────────────────────────────────────────
export const benchmarkSnapshots = mysqlTable("benchmark_snapshots", {
  id: int("id").autoincrement().primaryKey(),
  benchmarkVersionId: int("benchmarkVersionId"),
  snapshotJson: json("snapshotJson").notNull(), // full benchmark state at time of snapshot
  description: text("description"),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type BenchmarkSnapshot = typeof benchmarkSnapshots.$inferSelect;
export type InsertBenchmarkSnapshot = typeof benchmarkSnapshots.$inferInsert;

// ─── Competitor Entities (Stage 1) ──────────────────────────────────────────
export const competitorEntities = mysqlTable("competitor_entities", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  headquarters: varchar("headquarters", { length: 255 }),
  segmentFocus: mysqlEnum("segmentFocus", [
    "affordable",
    "mid",
    "premium",
    "luxury",
    "ultra_luxury",
    "mixed",
  ]).default("mixed"),
  website: text("website"),
  logoUrl: text("logoUrl"),
  notes: text("notes"),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CompetitorEntity = typeof competitorEntities.$inferSelect;
export type InsertCompetitorEntity = typeof competitorEntities.$inferInsert;

// ─── Competitor Projects (Stage 1) ──────────────────────────────────────────
export const competitorProjects = mysqlTable("competitor_projects", {
  id: int("id").autoincrement().primaryKey(),
  competitorId: int("competitorId").notNull(), // FK to competitor_entities
  projectName: varchar("projectName", { length: 255 }).notNull(),
  location: varchar("location", { length: 255 }),
  segment: mysqlEnum("segment", [
    "affordable",
    "mid",
    "premium",
    "luxury",
    "ultra_luxury",
  ]),
  assetType: mysqlEnum("assetType", [
    "residential",
    "commercial",
    "hospitality",
    "mixed_use",
  ]).default("residential"),
  positioningKeywords: json("positioningKeywords"), // string[]
  interiorStyleSignals: json("interiorStyleSignals"), // string[]
  materialCues: json("materialCues"), // string[]
  amenityList: json("amenityList"), // string[]
  unitMix: text("unitMix"),
  priceIndicators: json("priceIndicators"), // { currency, min, max, per_unit }
  salesMessaging: json("salesMessaging"), // string[]
  differentiationClaims: json("differentiationClaims"), // string[]
  completionStatus: mysqlEnum("completionStatus", [
    "announced",
    "under_construction",
    "completed",
    "sold_out",
  ]),
  launchDate: varchar("launchDate", { length: 32 }),
  totalUnits: int("totalUnits"),
  architect: varchar("architect", { length: 255 }),
  interiorDesigner: varchar("interiorDesigner", { length: 255 }),
  sourceUrl: text("sourceUrl"),
  captureDate: timestamp("captureDate"),
  evidenceCitations: json("evidenceCitations"), // array of { field, snippet, source_url, capture_date }
  completenessScore: int("completenessScore"), // 0-100
  runId: varchar("runId", { length: 64 }),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CompetitorProject = typeof competitorProjects.$inferSelect;
export type InsertCompetitorProject = typeof competitorProjects.$inferInsert;

// ─── Trend Tags (Stage 1) ───────────────────────────────────────────────────
export const trendTags = mysqlTable("trend_tags", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 128 }).notNull().unique(),
  category: mysqlEnum("category", [
    "material_trend",
    "design_trend",
    "market_trend",
    "buyer_preference",
    "sustainability",
    "technology",
    "pricing",
    "other",
  ]).notNull(),
  description: text("description"),
  createdBy: int("createdBy"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type TrendTag = typeof trendTags.$inferSelect;
export type InsertTrendTag = typeof trendTags.$inferInsert;

// ─── Entity Tags (Stage 1 — Join Table) ─────────────────────────────────────
export const entityTags = mysqlTable("entity_tags", {
  id: int("id").autoincrement().primaryKey(),
  tagId: int("tagId").notNull(), // FK to trend_tags
  entityType: mysqlEnum("entityType", [
    "competitor_project",
    "scenario",
    "evidence_record",
    "project",
  ]).notNull(),
  entityId: int("entityId").notNull(),
  addedBy: int("addedBy"),
  addedAt: timestamp("addedAt").defaultNow().notNull(),
});

export type EntityTag = typeof entityTags.$inferSelect;
export type InsertEntityTag = typeof entityTags.$inferInsert;

// ─── Intelligence Audit Log (Stage 1) ───────────────────────────────────────
export const intelligenceAuditLog = mysqlTable("intelligence_audit_log", {
  id: int("id").autoincrement().primaryKey(),
  runType: mysqlEnum("runType", [
    "price_extraction",
    "competitor_extraction",
    "benchmark_proposal",
    "manual_entry",
  ]).notNull(),
  runId: varchar("runId", { length: 64 }).notNull().unique(),
  actor: int("actor"), // userId who triggered
  inputSummary: json("inputSummary"), // config/params used
  outputSummary: json("outputSummary"), // counts, coverage, errors
  sourcesProcessed: int("sourcesProcessed").default(0),
  recordsExtracted: int("recordsExtracted").default(0),
  errors: int("errors").default(0),
  errorDetails: json("errorDetails"),
  startedAt: timestamp("startedAt").notNull(),
  completedAt: timestamp("completedAt"),
});

export type IntelligenceAuditLogEntry = typeof intelligenceAuditLog.$inferSelect;
export type InsertIntelligenceAuditLogEntry = typeof intelligenceAuditLog.$inferInsert;

// ─── Evidence References (V2.2 — Evidence Traceability) ─────────────────────
export const evidenceReferences = mysqlTable("evidence_references", {
  id: int("id").autoincrement().primaryKey(),
  evidenceRecordId: int("evidenceRecordId").notNull(), // FK to evidence_records
  targetType: mysqlEnum("targetType", [
    "scenario",
    "decision_note",
    "explainability_driver",
    "design_brief",
    "report",
    "material_board",
    "pack_section",
  ]).notNull(),
  targetId: int("targetId").notNull(), // ID of the linked entity
  sectionLabel: varchar("sectionLabel", { length: 255 }), // e.g. "Materials Specification", "Cost Assumptions"
  citationText: text("citationText"), // inline citation snippet
  addedBy: int("addedBy"),
  addedAt: timestamp("addedAt").defaultNow().notNull(),
});

export type EvidenceReference = typeof evidenceReferences.$inferSelect;
export type InsertEvidenceReference = typeof evidenceReferences.$inferInsert;

// ─── Ingestion Runs (V2 — Live Market Ingestion) ──────────────────────────────
export const ingestionRuns = mysqlTable("ingestion_runs", {
  id: int("id").autoincrement().primaryKey(),
  runId: varchar("runId", { length: 64 }).notNull().unique(),
  trigger: mysqlEnum("trigger", ["manual", "scheduled", "api"]).notNull(),
  triggeredBy: int("triggeredBy"), // userId or null for scheduled
  status: mysqlEnum("status", ["running", "completed", "failed"]).default("running").notNull(),
  // Counts
  totalSources: int("totalSources").default(0).notNull(),
  sourcesSucceeded: int("sourcesSucceeded").default(0).notNull(),
  sourcesFailed: int("sourcesFailed").default(0).notNull(),
  recordsExtracted: int("recordsExtracted").default(0).notNull(),
  recordsInserted: int("recordsInserted").default(0).notNull(),
  duplicatesSkipped: int("duplicatesSkipped").default(0).notNull(),
  // Detail
  sourceBreakdown: json("sourceBreakdown"), // per-source { sourceId, name, status, extracted, inserted, duplicates, errors }
  errorSummary: json("errorSummary"), // [{ sourceId, error }]
  // Timing
  startedAt: timestamp("startedAt").notNull(),
  completedAt: timestamp("completedAt"),
  durationMs: int("durationMs"),
  // Metadata
  cronExpression: varchar("cronExpression", { length: 64 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type IngestionRun = typeof ingestionRuns.$inferSelect;
export type InsertIngestionRun = typeof ingestionRuns.$inferInsert;

// ─── Connector Health (V3 — Source Health Monitoring) ───────────────────────────
export const connectorHealth = mysqlTable("connector_health", {
  id: int("id").autoincrement().primaryKey(),
  runId: varchar("runId", { length: 64 }).notNull(), // FK to ingestion_runs.runId
  sourceId: varchar("sourceId", { length: 64 }).notNull(),
  sourceName: varchar("sourceName", { length: 255 }).notNull(),
  status: mysqlEnum("healthStatus", ["success", "partial", "failed"]).notNull(),
  httpStatusCode: int("httpStatusCode"),
  responseTimeMs: int("responseTimeMs"),
  recordsExtracted: int("recordsExtracted").default(0).notNull(),
  recordsInserted: int("recordsInserted").default(0).notNull(),
  duplicatesSkipped: int("duplicatesSkipped").default(0).notNull(),
  errorMessage: text("errorMessage"),
  errorType: varchar("errorType", { length: 64 }), // "dns_failure", "timeout", "http_error", "parse_error", "llm_error"
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ConnectorHealth = typeof connectorHealth.$inferSelect;
export type InsertConnectorHealth = typeof connectorHealth.$inferInsert;

// ─── Trend Snapshots (V3 — Analytical Intelligence) ──────────────────────────
export const trendSnapshots = mysqlTable("trend_snapshots", {
  id: int("id").autoincrement().primaryKey(),
  metric: varchar("metric", { length: 255 }).notNull(),
  category: varchar("category", { length: 128 }).notNull(),
  geography: varchar("geography", { length: 128 }).notNull(),
  dataPointCount: int("dataPointCount").default(0).notNull(),
  gradeACount: int("gradeACount").default(0).notNull(),
  gradeBCount: int("gradeBCount").default(0).notNull(),
  gradeCCount: int("gradeCCount").default(0).notNull(),
  uniqueSources: int("uniqueSources").default(0).notNull(),
  dateRangeStart: timestamp("dateRangeStart"),
  dateRangeEnd: timestamp("dateRangeEnd"),
  currentMA: decimal("currentMA", { precision: 14, scale: 4 }),
  previousMA: decimal("previousMA", { precision: 14, scale: 4 }),
  percentChange: decimal("percentChange", { precision: 10, scale: 6 }),
  direction: mysqlEnum("direction", ["rising", "falling", "stable", "insufficient_data"]).notNull(),
  anomalyCount: int("anomalyCount").default(0).notNull(),
  anomalyDetails: json("anomalyDetails"), // AnomalyFlag[]
  confidence: mysqlEnum("trendConfidence", ["high", "medium", "low", "insufficient"]).notNull(),
  narrative: text("narrative"),
  movingAverages: json("movingAverages"), // MovingAveragePoint[]
  ingestionRunId: varchar("ingestionRunId", { length: 64 }), // FK to ingestion_runs.runId
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type TrendSnapshot = typeof trendSnapshots.$inferSelect;
export type InsertTrendSnapshot = typeof trendSnapshots.$inferInsert;

// ─── Project Insights (V3 — Analytical Intelligence) ─────────────────────────
export const projectInsights = mysqlTable("project_insights", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId"), // nullable for system-wide insights
  insightType: mysqlEnum("insightType", [
    "cost_pressure",
    "market_opportunity",
    "competitor_alert",
    "trend_signal",
    "positioning_gap",
  ]).notNull(),
  severity: mysqlEnum("insightSeverity", ["critical", "warning", "info"]).notNull(),
  title: varchar("title", { length: 512 }).notNull(),
  body: text("body"),
  actionableRecommendation: text("actionableRecommendation"),
  confidenceScore: decimal("confidenceScore", { precision: 5, scale: 4 }),
  triggerCondition: text("triggerCondition"),
  dataPoints: json("dataPoints"),
  status: mysqlEnum("insightStatus", ["active", "acknowledged", "dismissed", "resolved"]).default("active").notNull(),
  acknowledgedBy: int("acknowledgedBy"),
  acknowledgedAt: timestamp("acknowledgedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ProjectInsight = typeof projectInsights.$inferSelect;
export type InsertProjectInsight = typeof projectInsights.$inferInsert;

export const priceChangeEvents = mysqlTable("price_change_events", {
  id: int("id").autoincrement().primaryKey(),
  itemName: varchar("itemName", { length: 255 }).notNull(),
  category: varchar("category", { length: 255 }).notNull(),
  sourceId: int("sourceId").notNull(),
  previousPrice: decimal("previousPrice", { precision: 12, scale: 2 }).notNull(),
  newPrice: decimal("newPrice", { precision: 12, scale: 2 }).notNull(),
  changePct: decimal("changePct", { precision: 10, scale: 6 }).notNull(),
  changeDirection: mysqlEnum("changeDirection", ["increased", "decreased"]).notNull(),
  severity: mysqlEnum("severity", ["significant", "notable", "minor", "none"]).notNull(),
  detectedAt: timestamp("detectedAt").defaultNow().notNull(),
});

export type PriceChangeEvent = typeof priceChangeEvents.$inferSelect;
export type InsertPriceChangeEvent = typeof priceChangeEvents.$inferInsert;

// ─── Platform Alerts (V6 — Autonomous Intelligence) ─────────────────────────
export const platformAlerts = mysqlTable("platform_alerts", {
  id: int("id").autoincrement().primaryKey(),
  alertType: mysqlEnum("alertType", [
    "price_shock",
    "project_at_risk",
    "accuracy_degraded",
    "pattern_warning",
    "benchmark_drift",
    "market_opportunity"
  ]).notNull(),
  severity: mysqlEnum("severity", ["critical", "high", "medium", "info"]).notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  body: text("body").notNull(),
  affectedProjectIds: json("affectedProjectIds"),
  affectedCategories: json("affectedCategories"),
  triggerData: json("triggerData"),
  suggestedAction: text("suggestedAction").notNull(),
  status: mysqlEnum("status", ["active", "acknowledged", "resolved", "expired"]).default("active").notNull(),
  acknowledgedBy: int("acknowledgedBy"),
  acknowledgedAt: timestamp("acknowledgedAt"),
  expiresAt: timestamp("expiresAt").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type PlatformAlert = typeof platformAlerts.$inferSelect;
export type InsertPlatformAlert = typeof platformAlerts.$inferInsert;

// ─── NL Query Log (V7 — Production Hardening) ───────────────────────────────
export const nlQueryLog = mysqlTable("nl_query_log", {
  id: int("id").primaryKey().autoincrement(),
  userId: int("user_id").notNull(),
  queryText: text("query_text").notNull(),
  sqlGenerated: text("sql_generated"),
  rowsReturned: int("rows_returned").default(0),
  executionMs: int("execution_ms"),
  status: mysqlEnum("status", ["success", "error", "blocked"]).default("success"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type NlQueryLog = typeof nlQueryLog.$inferSelect;
export type InsertNlQueryLog = typeof nlQueryLog.$inferInsert;

// ─── V8 - Design Intelligence Layer ───────────────────────────────────────
export const materialLibrary = mysqlTable("material_library", {
  id: int("id").primaryKey().autoincrement(),
  category: mysqlEnum("category", [
    "flooring", "wall_paint", "wall_tile", "ceiling",
    "joinery", "sanitaryware", "fittings", "lighting",
    "hardware", "specialty"
  ]).notNull(),
  tier: mysqlEnum("tier", [
    "affordable", "mid", "premium", "ultra"
  ]).notNull(),
  style: mysqlEnum("style", [
    "modern", "contemporary", "classic",
    "minimalist", "arabesque", "all"
  ]).default("all").notNull(),
  productCode: varchar("product_code", { length: 100 }),
  productName: varchar("product_name", { length: 300 }).notNull(),
  brand: varchar("brand", { length: 150 }).notNull(),
  supplierName: varchar("supplier_name", { length: 200 }).notNull(),
  supplierLocation: varchar("supplier_location", { length: 200 }),
  supplierPhone: varchar("supplier_phone", { length: 50 }),
  unitLabel: varchar("unit_label", { length: 30 }).notNull(),
  priceAedMin: decimal("price_aed_min", { precision: 10, scale: 2 }),
  priceAedMax: decimal("price_aed_max", { precision: 10, scale: 2 }),
  notes: text("notes"),
  isActive: boolean("is_active").default(true).notNull(),
});

export type MaterialLibrary = typeof materialLibrary.$inferSelect;
export type InsertMaterialLibrary = typeof materialLibrary.$inferInsert;

export const finishScheduleItems = mysqlTable(
  "finish_schedule_items", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  roomId: varchar("room_id", { length: 10 }).notNull(),
  roomName: varchar("room_name", { length: 100 }).notNull(),
  element: mysqlEnum("element", [
    "floor", "wall_primary", "wall_feature",
    "wall_wet", "ceiling", "joinery", "hardware"
  ]).notNull(),
  materialLibraryId: int("material_library_id"),
  overrideSpec: varchar("override_spec", { length: 500 }),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type FinishScheduleItem = typeof finishScheduleItems.$inferSelect;
export type InsertFinishScheduleItem = typeof finishScheduleItems.$inferInsert;

export const projectColorPalettes = mysqlTable(
  "project_color_palettes", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  paletteKey: varchar("palette_key", { length: 100 }).notNull(),
  colors: json("colors").notNull(),
  geminiRationale: text("gemini_rationale"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type ProjectColorPalette = typeof projectColorPalettes.$inferSelect;
export type InsertProjectColorPalette = typeof projectColorPalettes.$inferInsert;

export const rfqLineItems = mysqlTable("rfq_line_items", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  sectionNo: int("section_no").notNull(),
  itemCode: varchar("item_code", { length: 20 }).notNull(),
  description: varchar("description", { length: 500 }).notNull(),
  unit: varchar("unit", { length: 20 }).notNull(),
  quantity: decimal("quantity", { precision: 10, scale: 2 }),
  unitRateAedMin: decimal("unit_rate_aed_min",
    { precision: 10, scale: 2 }),
  unitRateAedMax: decimal("unit_rate_aed_max",
    { precision: 10, scale: 2 }),
  totalAedMin: decimal("total_aed_min",
    { precision: 12, scale: 2 }),
  totalAedMax: decimal("total_aed_max",
    { precision: 12, scale: 2 }),
  supplierName: varchar("supplier_name", { length: 200 }),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type RfqLineItem = typeof rfqLineItems.$inferSelect;
export type InsertRfqLineItem = typeof rfqLineItems.$inferInsert;

export const dmComplianceChecklists = mysqlTable(
  "dm_compliance_checklists", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  organizationId: int("organization_id").notNull(),
  items: json("items").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type DmComplianceChecklist = typeof dmComplianceChecklists.$inferSelect;
export type InsertDmComplianceChecklist = typeof dmComplianceChecklists.$inferInsert;

// ─── V9 - Strategic Risk & Economic Modeling ────────────────────────────────

export const projectRoiModels = mysqlTable("project_roi_models", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  scenarioId: int("scenario_id"),
  reworkCostAvoided: decimal("rework_cost_avoided", { precision: 14, scale: 2 }).notNull(),
  programmeAccelerationValue: decimal("programme_acceleration_value", { precision: 14, scale: 2 }).notNull(),
  totalValueCreated: decimal("total_value_created", { precision: 14, scale: 2 }).notNull(),
  netRoiPercent: decimal("net_roi_percent", { precision: 8, scale: 2 }).notNull(),
  confidenceMultiplier: decimal("confidence_multiplier", { precision: 5, scale: 4 }).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type ProjectRoiModel = typeof projectRoiModels.$inferSelect;
export type InsertProjectRoiModel = typeof projectRoiModels.$inferInsert;

export const scenarioStressTests = mysqlTable("scenario_stress_tests", {
  id: int("id").primaryKey().autoincrement(),
  scenarioId: int("scenario_id").notNull(),
  stressCondition: varchar("stress_condition", { length: 100 }).notNull(),
  impactMagnitudePercent: decimal("impact_magnitude_percent", { precision: 6, scale: 2 }).notNull(),
  resilienceScore: int("resilience_score").notNull(), // 1-100
  failurePoints: json("failure_points").notNull(), // JSON array of components that fail
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type ScenarioStressTest = typeof scenarioStressTests.$inferSelect;
export type InsertScenarioStressTest = typeof scenarioStressTests.$inferInsert;

export const riskSurfaceMaps = mysqlTable("risk_surface_maps", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  domain: varchar("domain", { length: 100 }).notNull(),
  probability: int("probability").notNull(), // 0-100
  impact: int("impact").notNull(), // 0-100
  vulnerability: int("vulnerability").notNull(), // 0-100
  controlStrength: int("control_strength").notNull(), // 1-100
  compositeRiskScore: int("composite_risk_score").notNull(), // Calculated via R = (P * I * V) / C
  riskBand: mysqlEnum("risk_band", ["Minimal", "Controlled", "Elevated", "Critical", "Systemic"]).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type RiskSurfaceMap = typeof riskSurfaceMaps.$inferSelect;
export type InsertRiskSurfaceMap = typeof riskSurfaceMaps.$inferInsert;

// ─── V11: Cognitive Bias Framework ──────────────────────────────────────────

export const biasAlerts = mysqlTable("bias_alerts", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("projectId").notNull(),
  scoreMatrixId: int("scoreMatrixId"),
  userId: int("userId").notNull(),
  orgId: int("orgId"),
  biasType: mysqlEnum("biasType", [
    "optimism_bias",
    "anchoring_bias",
    "confirmation_bias",
    "overconfidence",
    "scope_creep",
    "sunk_cost",
    "clustering_illusion",
  ]).notNull(),
  severity: mysqlEnum("severity", ["low", "medium", "high", "critical"]).notNull(),
  confidence: decimal("confidence", { precision: 5, scale: 2 }).notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  intervention: text("intervention"),
  evidencePoints: json("evidencePoints"),
  mathExplanation: text("mathExplanation"),
  dismissed: boolean("dismissed").default(false),
  dismissedBy: int("dismissedBy"),
  dismissedAt: timestamp("dismissedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type BiasAlertRow = typeof biasAlerts.$inferSelect;
export type InsertBiasAlert = typeof biasAlerts.$inferInsert;

export const biasProfiles = mysqlTable("bias_profiles", {
  id: int("id").primaryKey().autoincrement(),
  userId: int("userId").notNull(),
  orgId: int("orgId"),
  biasType: varchar("biasType", { length: 64 }).notNull(),
  occurrenceCount: int("occurrenceCount").default(0),
  lastDetectedAt: timestamp("lastDetectedAt"),
  avgSeverity: decimal("avgSeverity", { precision: 3, scale: 2 }),
  trend: mysqlEnum("trend", ["increasing", "stable", "decreasing"]).default("stable"),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type BiasProfileRow = typeof biasProfiles.$inferSelect;
export type InsertBiasProfile = typeof biasProfiles.$inferInsert;

// ─── Phase 1: Smart Design Brain ────────────────────────────────────────────

export const spaceRecommendations = mysqlTable("space_recommendations", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  orgId: int("org_id").notNull(),
  roomId: varchar("room_id", { length: 10 }).notNull(),
  roomName: varchar("room_name", { length: 100 }).notNull(),
  sqm: decimal("sqm", { precision: 8, scale: 2 }),
  styleDirection: varchar("style_direction", { length: 500 }),
  colorScheme: varchar("color_scheme", { length: 500 }),
  materialPackage: json("material_package"),       // MaterialRec[]
  budgetAllocation: decimal("budget_allocation", { precision: 12, scale: 2 }),
  budgetBreakdown: json("budget_breakdown"),        // BudgetBreakdownItem[]
  aiRationale: text("ai_rationale"),
  specialNotes: json("special_notes"),              // string[]
  kitchenSpec: json("kitchen_spec"),                // KitchenSpec | null
  bathroomSpec: json("bathroom_spec"),              // BathroomSpec | null
  alternatives: json("alternatives"),               // AlternativePackage[]
  generatedAt: timestamp("generated_at").defaultNow().notNull(),
});

export type SpaceRecommendationRow = typeof spaceRecommendations.$inferSelect;
export type InsertSpaceRecommendation = typeof spaceRecommendations.$inferInsert;

export const designPackages = mysqlTable("design_packages", {
  id: int("id").primaryKey().autoincrement(),
  orgId: int("org_id"),
  name: varchar("name", { length: 200 }).notNull(),
  typology: varchar("typology", { length: 100 }).notNull(),
  tier: varchar("tier", { length: 50 }).notNull(),
  style: varchar("style", { length: 100 }).notNull(),
  description: text("description"),
  targetBudgetPerSqm: decimal("target_budget_per_sqm", { precision: 10, scale: 2 }),
  rooms: json("rooms"),                            // SpaceRecommendation[]
  isTemplate: boolean("is_template").default(false).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull(),
});

export type DesignPackageRow = typeof designPackages.$inferSelect;
export type InsertDesignPackage = typeof designPackages.$inferInsert;

export const aiDesignBriefs = mysqlTable("ai_design_briefs", {
  id: int("id").primaryKey().autoincrement(),
  projectId: int("project_id").notNull(),
  orgId: int("org_id").notNull(),
  briefData: json("brief_data").notNull(),          // AIDesignBrief
  version: varchar("version", { length: 20 }).default("1.0"),
  generatedAt: timestamp("generated_at").defaultNow().notNull(),
});

export type AiDesignBriefRow = typeof aiDesignBriefs.$inferSelect;
export type InsertAiDesignBrief = typeof aiDesignBriefs.$inferInsert;
```

### 2. Four Specialized LLM Prompts

| Source Type | Prompt Focus | Key Fields |
|---|---|---|
| **Suppliers** (supplier_catalog, manufacturer_catalog, retailer, aggregator) | "Extract products with **EXACT AED prices**" | value, valueMax, unit, category, brand |
| **Developers** (developer_brochure) | "Extract **interior design intelligence** — NOT property prices" | finishLevel, designStyle, brands[], materialSpec |
| **Research** (industry_report, trade_publication) | "Extract **market statistics and trends**" | value, unit, trend, category |
| **Government** (government_tender, procurement_portal) | "Extract **construction/real estate data**" | value, unit, publishedDate |

```diff:dynamic.ts
import { BaseSourceConnector } from "../connector";
import type { RawSourcePayload, ExtractedEvidence, NormalizedEvidenceInput } from "../connector";
import { assignGrade, computeConfidence } from "../connector";
import { invokeLLM } from "../../../_core/llm";

// LLM extraction template similar to index.ts but leveraging extractionHints
const LLM_EXTRACTION_SYSTEM_PROMPT = `You are a data extraction engine for the MIYAR real estate intelligence platform.
You extract structured evidence from raw HTML or JSON content of UAE construction/real estate websites.
Return ONLY valid JSON. Do not include markdown code fences or any other text.`;

function buildDynamicPrompt(
    sourceName: string,
    category: string,
    geography: string,
    contentSnippet: string,
    hints?: string,
    lastFetch?: Date
): string {
    const dateFilter = lastFetch
        ? `\nFocus on content published or updated after ${lastFetch.toISOString().split("T")[0]}.`
        : "";

    const hintsFilter = hints ? `\nEXTRACTION HINTS: ${hints}` : "";

    return `Extract evidence items from this ${sourceName} source content.
Category: ${category}
Geography: ${geography}${dateFilter}${hintsFilter}

Return a JSON array of objects with these exact fields:
- title: string (item/product/project name)
- rawText: string (relevant text snippet, max 500 chars)
- publishedDate: string|null (ISO date if found, null otherwise)
- metric: string (what is being measured, e.g. "Marble Tile 60x60 price")
- value: number|null (numeric value in AED if found, null otherwise)
- unit: string|null (e.g. "sqm", "sqft", "piece", "unit", null if not applicable)

Rules:
- Extract up to 15 items maximum
- Only extract items with real data (titles, prices, descriptions)
- Do NOT invent data — if no items found, return empty array []
- Do NOT output confidence, grade, or scoring fields

Content (truncated to 8000 chars):
${contentSnippet.substring(0, 8000)}`;
}

export class DynamicConnector extends BaseSourceConnector {
    sourceId: string;
    sourceName: string;
    sourceUrl: string;
    category: string;
    geography: string;

    scrapeMethod: string;
    extractionHints: string;
    defaultUnit: string = "unit";
    defaultTags: string[] = [];

    constructor(config: {
        id: number | string;
        name: string;
        url: string;
        sourceType?: string;
        region?: string;
        scrapeMethod?: string;
        extractionHints?: string;
        lastSuccessfulFetch?: Date | null;
    }) {
        super();
        this.sourceId = String(config.id);
        this.sourceName = config.name;
        this.sourceUrl = config.url;

        // Map sourceType to evidence category
        const typeCategoryMap: Record<string, string> = {
            supplier_catalog: "material_cost",
            manufacturer_catalog: "material_cost",
            retailer_listing: "material_cost",
            developer_brochure: "competitor_project",
            industry_report: "market_trend",
            government_tender: "project_award",
            trade_publication: "market_trend",
            other: "other"
        };

        this.category = typeCategoryMap[config.sourceType || "other"] || "other";
        this.geography = config.region || "UAE";
        this.scrapeMethod = config.scrapeMethod || "html_llm";
        this.extractionHints = config.extractionHints || "";

        if (config.lastSuccessfulFetch) {
            this.lastSuccessfulFetch = new Date(config.lastSuccessfulFetch);
        }
    }

    async extract(raw: RawSourcePayload): Promise<ExtractedEvidence[]> {
        const isHtml = !!raw.rawHtml;
        const content = isHtml ? raw.rawHtml! : JSON.stringify(raw.rawJson || {});

        if (!content || content.length < 50) return [];

        // For DFE-01, implement html_llm as the universal baseline for HTML/JSON
        if (this.scrapeMethod === "html_llm" || this.scrapeMethod === "json_api") {
            try {
                const textContent = isHtml
                    ? content.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "")
                        .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "")
                        .replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim()
                    : content;

                const response = await invokeLLM({
                    messages: [
                        { role: "system", content: LLM_EXTRACTION_SYSTEM_PROMPT },
                        {
                            role: "user",
                            content: buildDynamicPrompt(
                                this.sourceName,
                                this.category,
                                this.geography,
                                textContent,
                                this.extractionHints,
                                this.lastSuccessfulFetch
                            )
                        }
                    ],
                    response_format: { type: "json_object" }
                });

                const resText = typeof response.choices[0]?.message?.content === "string"
                    ? response.choices[0].message.content : "";

                if (!resText) return [];

                const parsed = JSON.parse(resText);
                const items = Array.isArray(parsed) ? parsed : (parsed.items || parsed.data || []);
                if (!Array.isArray(items)) return [];

                return items
                    .filter((item: any) => item && typeof item.title === "string" && item.title.length > 0)
                    .slice(0, 15)
                    .map((item: any) => ({
                        title: `${this.sourceName} - ${String(item.title).substring(0, 255)}`,
                        rawText: String(item.rawText || item.description || item.title || "").substring(0, 500),
                        publishedDate: item.publishedDate ? new Date(item.publishedDate) : undefined,
                        category: this.category,
                        geography: this.geography,
                        sourceUrl: raw.url,
                        _llmMetric: String(item.metric || item.title || "").substring(0, 255),
                        _llmValue: typeof item.value === "number" && isFinite(item.value) ? item.value : null,
                        _llmUnit: typeof item.unit === "string" ? item.unit : null,
                    } as any));
            } catch (err) {
                console.error(`[DynamicConnector] Extraction failed for ${this.sourceName}: `, err);
                return [];
            }
        }

        return [];
    }

    async normalize(evidence: ExtractedEvidence): Promise<NormalizedEvidenceInput> {
        const grade = assignGrade(this.sourceId);
        const confidence = computeConfidence(grade, evidence.publishedDate, new Date());
        const llmEvidence = evidence as any;

        return {
            metric: llmEvidence._llmMetric || evidence.title,
            value: llmEvidence._llmValue ?? null,
            unit: llmEvidence._llmUnit ?? this.defaultUnit,
            confidence,
            grade,
            summary: (evidence.rawText || "").replace(/\s+/g, " ").trim().substring(0, 500),
            tags: this.defaultTags
        };
    }
}
===
import { BaseSourceConnector } from "../connector";
import type { RawSourcePayload, ExtractedEvidence, NormalizedEvidenceInput } from "../connector";
import { assignGrade, computeConfidence, isFirecrawlAvailable } from "../connector";
import { invokeLLM } from "../../../_core/llm";
import { discoverLinks, DEFAULT_CRAWL_CONFIG, type CrawlConfig } from "../crawler";

// ─── LLM Prompts ────────────────────────────────────────────────

const LLM_EXTRACTION_SYSTEM_PROMPT = `You are a data extraction engine for the MIYAR real estate intelligence platform.
You extract structured evidence from website content of UAE construction/real estate websites.
Return ONLY valid JSON. Do not include markdown code fences or any other text.`;

// ─── Source-type-specific prompt builders ────────────────────────

/**
 * PROMPT A: Material Pricing — for supplier/manufacturer/retailer sources
 * Extracts: product names + AED prices + categories + brands
 */
function buildMaterialPricingPrompt(
    sourceName: string,
    geography: string,
    contentSnippet: string,
    hints?: string,
    pageUrl?: string,
): string {
    const hintsFilter = hints ? `\nEXTRACTION HINTS: ${hints}` : "";
    const pageRef = pageUrl ? `\nPage URL: ${pageUrl}` : "";

    return `Extract products with prices from this ${sourceName} supplier/retailer page.
Geography: ${geography}${pageRef}${hintsFilter}

IMPORTANT: Extract EXACT AED prices. If price is shown, include it. Skip items with no price.

Return a JSON array of objects with these EXACT fields:
- title: string (product name with specification, e.g. "Calacatta Marble Tile 60x60cm")
- rawText: string (product description or context, max 500 chars)
- value: number (price in AED — REQUIRED, skip items without price)
- valueMax: number|null (max price if a range is shown, e.g. for "85-110 AED/sqm" value=85, valueMax=110)
- unit: string (REQUIRED — "sqm", "piece", "unit", "m", "L", "set", etc.)
- category: string (one of: "floors", "walls", "ceilings", "sanitary", "lighting", "kitchen", "hardware", "joinery", "ffe", "other")
- brand: string|null (manufacturer/brand name if visible)
- publishedDate: string|null (ISO date if found)

Rules:
- Extract ALL priced items you can find, up to 50 maximum
- Price MUST be a number in AED — skip items with no visible price
- For price ranges like "85-110", set value=85 and valueMax=110
- Convert known currencies to AED (USD×3.67, EUR×4.0)
- Do NOT invent prices
- Return empty array [] if no priced items found

Content (truncated to 16000 chars):
${contentSnippet.substring(0, 16000)}`;
}

/**
 * PROMPT B: Developer Intelligence — for developer_brochure sources
 * Extracts: finish specs, design styles, brands, quality tier
 */
function buildDeveloperIntelPrompt(
    sourceName: string,
    geography: string,
    contentSnippet: string,
    hints?: string,
    pageUrl?: string,
): string {
    const hintsFilter = hints ? `\nEXTRACTION HINTS: ${hints}` : "";
    const pageRef = pageUrl ? `\nPage URL: ${pageUrl}` : "";

    return `Extract INTERIOR DESIGN intelligence from this ${sourceName} developer/project website.
Geography: ${geography}${pageRef}${hintsFilter}

FOCUS ON: finish specifications, material brands used, design aesthetic, quality tier.
DO NOT extract: property prices, bedroom counts, unit sizes, payment plans, or sales offers.

Return a JSON array of objects with these EXACT fields:
- title: string (project/development name)
- rawText: string (description of finishes and design, max 500 chars)
- finishLevel: string (one of: "basic", "standard", "premium", "luxury", "ultra_luxury")
- designStyle: string (aesthetic description, e.g. "Contemporary Italian", "Modern Arabic", "Minimalist Scandinavian", "Classic European")
- brands: string[] (brand names mentioned, e.g. ["Grohe", "Porcelanosa", "Miele", "Villeroy & Boch"])
- materialSpec: string (specific materials mentioned, e.g. "Imported marble flooring, engineered oak, quartz countertops, European kitchen appliances")
- category: string (main area — "floors", "walls", "sanitary", "kitchen", "joinery", "lighting", "ffe", "other")

Rules:
- ONE record per project/development (not per unit type)
- Focus on WHAT MATERIALS and FINISHES are used, not the property itself
- If the page describes kitchen specs, bathroom specs, floor specs — extract each as separate records
- If no interior design info found, return empty array []
- Look for words like: marble, granite, porcelain, hardwood, premium, luxury, European, imported, bespoke

Content (truncated to 16000 chars):
${contentSnippet.substring(0, 16000)}`;
}

/**
 * PROMPT C: Market Research — for industry_report/trade_publication sources
 * Extracts: market statistics, trends, forecasts, cost benchmarks
 */
function buildMarketResearchPrompt(
    sourceName: string,
    geography: string,
    contentSnippet: string,
    hints?: string,
    pageUrl?: string,
): string {
    const hintsFilter = hints ? `\nEXTRACTION HINTS: ${hints}` : "";
    const pageRef = pageUrl ? `\nPage URL: ${pageUrl}` : "";

    return `Extract market intelligence and construction/real estate statistics from this ${sourceName} report.
Geography: ${geography}${pageRef}${hintsFilter}

FOCUS ON: price indices, construction cost benchmarks, market trends, supply/demand data, forecasts.

Return a JSON array of objects with these EXACT fields:
- title: string (statistic or finding name, e.g. "Average Fitout Cost - Luxury Residential")
- rawText: string (the finding with context, max 500 chars)
- value: number|null (numeric value in AED if applicable)
- unit: string|null (e.g. "sqft", "sqm", "percent", "index", "AED/sqm")
- trend: string|null (one of: "rising", "stable", "falling", or null if not a trend)
- publishedDate: string|null (ISO date if found)
- category: string (one of: "floors", "walls", "ceilings", "sanitary", "lighting", "kitchen", "hardware", "joinery", "ffe", "other")

Rules:
- Extract ALL statistics, data points, and findings — up to 50 maximum
- Include forecasts and projections with timeframe in rawText
- Include percentage changes and growth rates
- If no relevant data found, return empty array []

Content (truncated to 16000 chars):
${contentSnippet.substring(0, 16000)}`;
}

/**
 * PROMPT D: Government Data — for government_tender/procurement sources
 * Extracts: permits, regulations, cost indices, tenders
 */
function buildGovernmentDataPrompt(
    sourceName: string,
    geography: string,
    contentSnippet: string,
    hints?: string,
    pageUrl?: string,
): string {
    const hintsFilter = hints ? `\nEXTRACTION HINTS: ${hints}` : "";
    const pageRef = pageUrl ? `\nPage URL: ${pageUrl}` : "";

    return `Extract construction and real estate data from this ${sourceName} government source.
Geography: ${geography}${pageRef}${hintsFilter}

FOCUS ON: building permits, construction statistics, cost indices, regulations, standards.

Return a JSON array of objects with these EXACT fields:
- title: string (data point, regulation, or statistic name)
- rawText: string (description or finding, max 500 chars)
- value: number|null (numeric value if applicable)
- unit: string|null (measurement unit)
- publishedDate: string|null (ISO date if found)
- category: string ("other" for most government data)

Rules:
- Extract data relevant to construction, interior design, and real estate
- Include regulatory changes affecting building standards
- If no relevant data found, return empty array []

Content (truncated to 16000 chars):
${contentSnippet.substring(0, 16000)}`;
}

// ─── Prompt selector ────────────────────────────────────────────

type SourceTypeKey = "supplier_catalog" | "manufacturer_catalog" | "retailer_listing" | "aggregator" |
    "developer_brochure" | "industry_report" | "trade_publication" |
    "government_tender" | "procurement_portal" | "other";

function selectPrompt(
    sourceType: string,
    sourceName: string,
    geography: string,
    contentSnippet: string,
    hints?: string,
    pageUrl?: string,
): string {
    switch (sourceType) {
        case "supplier_catalog":
        case "manufacturer_catalog":
        case "retailer_listing":
        case "aggregator":
            return buildMaterialPricingPrompt(sourceName, geography, contentSnippet, hints, pageUrl);
        case "developer_brochure":
            return buildDeveloperIntelPrompt(sourceName, geography, contentSnippet, hints, pageUrl);
        case "industry_report":
        case "trade_publication":
            return buildMarketResearchPrompt(sourceName, geography, contentSnippet, hints, pageUrl);
        case "government_tender":
        case "procurement_portal":
            return buildGovernmentDataPrompt(sourceName, geography, contentSnippet, hints, pageUrl);
        default:
            // Fallback: use material pricing as default
            return buildMaterialPricingPrompt(sourceName, geography, contentSnippet, hints, pageUrl);
    }
}

// ─── Intelligence type mapping ──────────────────────────────────

function getIntelligenceType(sourceType: string): string {
    switch (sourceType) {
        case "supplier_catalog":
        case "manufacturer_catalog":
        case "retailer_listing":
        case "aggregator":
            return "material_price";
        case "developer_brochure":
            return "finish_specification";
        case "industry_report":
        case "trade_publication":
            return "market_statistic";
        case "government_tender":
        case "procurement_portal":
            return "regulation";
        default:
            return "material_price";
    }
}

// ─── Source types that benefit from multi-page crawling ──────────

const CRAWLABLE_TYPES = new Set([
    "supplier_catalog",
    "manufacturer_catalog",
    "retailer_listing",
    "aggregator",
]);

export class DynamicConnector extends BaseSourceConnector {
    sourceId: string;
    sourceName: string;
    sourceUrl: string;
    category: string;
    geography: string;

    scrapeMethod: string;
    extractionHints: string;
    defaultUnit: string = "unit";
    defaultTags: string[] = [];

    private sourceType: string;
    private crawlConfig: CrawlConfig;

    /** Accumulates extracted evidence from all crawled pages */
    private _allPageEvidence: ExtractedEvidence[] = [];
    private _crawled = false;

    constructor(config: {
        id: number | string;
        name: string;
        url: string;
        sourceType?: string;
        region?: string;
        scrapeMethod?: string;
        extractionHints?: string;
        lastSuccessfulFetch?: Date | null;
        requestDelayMs?: number;
        scrapeConfig?: any;
    }) {
        super();
        this.sourceId = String(config.id);
        this.sourceName = config.name;
        this.sourceUrl = config.url;

        const typeCategoryMap: Record<string, string> = {
            supplier_catalog: "floors",
            manufacturer_catalog: "floors",
            retailer_listing: "floors",
            developer_brochure: "other",
            industry_report: "other",
            government_tender: "other",
            trade_publication: "other",
            aggregator: "floors",
            other: "other"
        };

        this.sourceType = config.sourceType || "other";
        this.category = typeCategoryMap[this.sourceType] || "other";
        this.geography = config.region || "UAE";
        this.scrapeMethod = config.scrapeMethod || "html_llm";
        this.extractionHints = config.extractionHints || "";

        if (config.lastSuccessfulFetch) {
            this.lastSuccessfulFetch = new Date(config.lastSuccessfulFetch);
        }

        const userCrawl = config.scrapeConfig?.crawl || {};
        this.crawlConfig = {
            ...DEFAULT_CRAWL_CONFIG,
            requestDelayMs: config.requestDelayMs || DEFAULT_CRAWL_CONFIG.requestDelayMs,
            ...userCrawl,
        };

        if (config.requestDelayMs) {
            this.requestDelayMs = config.requestDelayMs;
        }
    }

    shouldCrawl(): boolean {
        return CRAWLABLE_TYPES.has(this.sourceType) && this.crawlConfig.maxDepth > 0;
    }

    /**
     * Fetch with multi-page crawling for catalog sources.
     * Uses Firecrawl when available for JS-rendered pages.
     */
    async fetch(): Promise<RawSourcePayload> {
        const localBudget = process.env.LOCAL_PAGE_BUDGET
            ? parseInt(process.env.LOCAL_PAGE_BUDGET, 10)
            : undefined;

        if (localBudget) {
            this.crawlConfig = { ...this.crawlConfig, pageBudget: localBudget };
        }

        if (!this.shouldCrawl()) {
            // Single-page mode — use Firecrawl or basic fetch
            if (isFirecrawlAvailable()) {
                return this.fetchWithFirecrawl();
            }
            return super.fetch();
        }

        // Multi-page crawl mode (BFS)
        console.log(`[DynamicConnector] 🕷️  Crawling ${this.sourceName} (max ${this.crawlConfig.pageBudget} pages, depth ${this.crawlConfig.maxDepth})`);

        const visited = new Set<string>();
        const queue: Array<{ url: string; depth: number }> = [{ url: this.sourceUrl, depth: 0 }];
        const allEvidence: ExtractedEvidence[] = [];
        let pagesProcessed = 0;
        let pagesFailed = 0;

        while (queue.length > 0 && pagesProcessed < this.crawlConfig.pageBudget) {
            const { url, depth } = queue.shift()!;
            const normalizedUrl = url.replace(/\/$/, "");

            if (visited.has(normalizedUrl)) continue;
            visited.add(normalizedUrl);

            // Fetch this page (using Firecrawl if available)
            let payload: RawSourcePayload;
            try {
                if (isFirecrawlAvailable()) {
                    payload = await this.fetchWithFirecrawl(url);
                } else {
                    payload = await this.fetchBasic(url);
                }
            } catch (err) {
                console.warn(`[DynamicConnector] Page fetch failed: ${url}`);
                pagesFailed++;
                continue;
            }

            if (payload.error || (!payload.rawHtml && !payload.markdown) ||
                ((payload.rawHtml?.length || 0) + (payload.markdown?.length || 0)) < 100) {
                pagesFailed++;
                continue;
            }

            pagesProcessed++;

            // Extract evidence from this page using LLM
            try {
                const content = payload.markdown || payload.rawHtml || "";
                const evidence = await this.extractFromContent(content, url, !!payload.markdown);
                if (evidence.length > 0) {
                    console.log(`[DynamicConnector]   📄 ${url} → ${evidence.length} items`);
                    allEvidence.push(...evidence);
                }
            } catch (err) {
                console.warn(`[DynamicConnector]   ⚠️  Extraction failed for ${url}`);
            }

            // Discover internal links if within depth limit (use HTML for link discovery)
            if (depth < this.crawlConfig.maxDepth && payload.rawHtml) {
                const links = discoverLinks(payload.rawHtml, url, this.crawlConfig);
                for (const link of links) {
                    const normLink = link.replace(/\/$/, "");
                    if (!visited.has(normLink) && !queue.some(q => q.url.replace(/\/$/, "") === normLink)) {
                        queue.push({ url: link, depth: depth + 1 });
                    }
                }
            }

            // Rate limit between pages
            if (queue.length > 0 && pagesProcessed < this.crawlConfig.pageBudget) {
                await new Promise(r => setTimeout(r, this.crawlConfig.requestDelayMs));
            }
        }

        console.log(`[DynamicConnector] 🕷️  Crawl complete: ${pagesProcessed} pages, ${allEvidence.length} items extracted, ${pagesFailed} failed`);

        this._allPageEvidence = allEvidence;
        this._crawled = true;

        return {
            url: this.sourceUrl,
            rawHtml: `<!-- Crawled ${pagesProcessed} pages, ${allEvidence.length} items extracted -->`,
            statusCode: 200,
            fetchedAt: new Date(),
        };
    }

    /**
     * Extract evidence from content using LLM.
     * Uses source-type-specific prompts for targeted extraction.
     */
    private async extractFromContent(content: string, pageUrl: string, isMarkdown: boolean): Promise<ExtractedEvidence[]> {
        let textContent: string;

        if (isMarkdown) {
            textContent = content.trim();
        } else {
            textContent = content
                .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "")
                .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "")
                .replace(/<[^>]+>/g, " ")
                .replace(/\s+/g, " ")
                .trim();
        }

        if (textContent.length < 50) return [];

        try {
            // Select prompt based on source type
            const prompt = selectPrompt(
                this.sourceType,
                this.sourceName,
                this.geography,
                textContent,
                this.extractionHints,
                pageUrl,
            );

            const response = await invokeLLM({
                messages: [
                    { role: "system", content: LLM_EXTRACTION_SYSTEM_PROMPT },
                    { role: "user", content: prompt }
                ],
                response_format: { type: "json_object" }
            });

            const resText = typeof response.choices[0]?.message?.content === "string"
                ? response.choices[0].message.content : "";

            if (!resText) return [];

            const parsed = JSON.parse(resText);
            const items = Array.isArray(parsed) ? parsed : (parsed.items || parsed.data || []);
            if (!Array.isArray(items)) return [];

            const intelligenceType = getIntelligenceType(this.sourceType);

            return items
                .filter((item: any) => item && typeof item.title === "string" && item.title.length > 0)
                .slice(0, 50)
                .map((item: any) => ({
                    title: String(item.title).substring(0, 255),
                    rawText: String(item.rawText || item.description || item.title || "").substring(0, 500),
                    publishedDate: item.publishedDate ? new Date(item.publishedDate) : undefined,
                    category: item.category || this.category,
                    geography: this.geography,
                    sourceUrl: pageUrl,
                    // Material pricing fields
                    _llmMetric: String(item.metric || item.title || "").substring(0, 255),
                    _llmValue: typeof item.value === "number" && isFinite(item.value) ? item.value : null,
                    _llmValueMax: typeof item.valueMax === "number" && isFinite(item.valueMax) ? item.valueMax : null,
                    _llmUnit: typeof item.unit === "string" ? item.unit : null,
                    _llmBrand: typeof item.brand === "string" ? item.brand : null,
                    // Design intelligence fields
                    _llmFinishLevel: typeof item.finishLevel === "string" ? item.finishLevel : null,
                    _llmDesignStyle: typeof item.designStyle === "string" ? item.designStyle : null,
                    _llmBrands: Array.isArray(item.brands) ? item.brands : null,
                    _llmMaterialSpec: typeof item.materialSpec === "string" ? item.materialSpec : null,
                    _llmIntelligenceType: intelligenceType,
                } as any));
        } catch (err) {
            console.error(`[DynamicConnector] LLM extraction failed for ${pageUrl}:`, err);
            return [];
        }
    }

    /**
     * Called by orchestrator after fetch().
     * For multi-page crawls, returns pre-accumulated evidence.
     * For single-page, runs LLM extraction on fetched content.
     */
    async extract(raw: RawSourcePayload): Promise<ExtractedEvidence[]> {
        if (this._crawled && this._allPageEvidence.length > 0) {
            const evidence = [...this._allPageEvidence];
            this._allPageEvidence = [];
            this._crawled = false;
            return evidence;
        }

        // Single-page extraction — prefer markdown over HTML
        const content = raw.markdown || raw.rawHtml || JSON.stringify(raw.rawJson || {});
        if (!content || content.length < 50) return [];

        const isMarkdown = !!raw.markdown;
        return this.extractFromContent(
            isMarkdown ? content : (raw.rawHtml ? content : `<pre>${content}</pre>`),
            raw.url,
            isMarkdown,
        );
    }

    async normalize(evidence: ExtractedEvidence): Promise<NormalizedEvidenceInput> {
        const grade = assignGrade(this.sourceId);
        const confidence = computeConfidence(grade, evidence.publishedDate, new Date());
        const llmEvidence = evidence as any;

        return {
            metric: llmEvidence._llmMetric || evidence.title,
            value: llmEvidence._llmValue ?? null,
            valueMax: llmEvidence._llmValueMax ?? null,
            unit: llmEvidence._llmUnit ?? this.defaultUnit,
            confidence,
            grade,
            summary: (evidence.rawText || "").replace(/\s+/g, " ").trim().substring(0, 500),
            tags: this.defaultTags,
            brand: llmEvidence._llmBrand ?? null,
            // Design intelligence fields
            finishLevel: llmEvidence._llmFinishLevel ?? null,
            designStyle: llmEvidence._llmDesignStyle ?? null,
            brandsMentioned: llmEvidence._llmBrands ?? null,
            materialSpec: llmEvidence._llmMaterialSpec ?? null,
            intelligenceType: llmEvidence._llmIntelligenceType ?? "material_price",
        };
    }
}
```

### 3. Fixed Category Mapping + Record Insertion

```diff:orchestrator.ts
/**
 * MIYAR V2 — Ingestion Orchestrator
 *
 * Central orchestrator that manages connector execution, queuing,
 * and result persistence. Executes connectors in parallel (max 3
 * concurrent), handles failures gracefully, detects duplicates,
 * and logs all events to the audit log.
 */

import { randomUUID } from "crypto";
import type {
  SourceConnector,
  ExtractedEvidence,
  NormalizedEvidenceInput,
} from "./connector";
import {
  extractedEvidenceSchema,
  normalizedEvidenceInputSchema,
} from "./connector";
import {
  createEvidenceRecord,
  createIntelligenceAuditEntry,
  insertConnectorHealth,
  insertTrendSnapshot,
  getDb,
  getEvidenceRecordById
} from "../../db";
import { generateBenchmarkProposals } from "./proposal-generator";
import { triggerAlertEngine } from "../autonomous/alert-engine";
import { detectPriceChange } from "./change-detector";
import { detectTrends, type DataPoint } from "../analytics/trend-detection";
import { evidenceRecords, ingestionRuns, sourceRegistry } from "../../../drizzle/schema";
import { and, eq, sql } from "drizzle-orm";

// ─── Types ───────────────────────────────────────────────────────

export interface IngestionRunReport {
  runId: string;
  startedAt: Date;
  completedAt: Date;
  durationMs: number;
  triggeredBy: "manual" | "scheduled" | "api";
  sourcesAttempted: number;
  sourcesSucceeded: number;
  sourcesFailed: number;
  evidenceCreated: number;
  evidenceSkipped: number;
  errors: Array<{ sourceId: string; sourceName: string; error: string }>;
  perSource: Array<{
    sourceId: string;
    sourceName: string;
    status: "success" | "failed";
    evidenceExtracted: number;
    evidenceCreated: number;
    evidenceSkipped: number;
    error?: string;
  }>;
}

interface ConnectorResult {
  sourceId: string;
  sourceName: string;
  status: "success" | "failed";
  evidenceExtracted: number;
  evidenceCreated: number;
  evidenceSkipped: number;
  error?: string;
}

// ─── Concurrency Limiter ─────────────────────────────────────────

const MAX_CONCURRENT = 3;

async function runWithConcurrencyLimit<T>(
  tasks: Array<() => Promise<T>>,
  limit: number
): Promise<T[]> {
  const results: T[] = [];
  let index = 0;

  async function runNext(): Promise<void> {
    while (index < tasks.length) {
      const currentIndex = index++;
      results[currentIndex] = await tasks[currentIndex]();
    }
  }

  const workers = Array.from(
    { length: Math.min(limit, tasks.length) },
    () => runNext()
  );

  await Promise.all(workers);
  return results;
}

// ─── Duplicate Detection ─────────────────────────────────────────

/**
 * Check if an evidence record from the same source URL + item name
 * + capture date already exists. Uses sourceUrl + itemName + captureDate
 * as the composite uniqueness key.
 */
async function isDuplicate(
  sourceUrl: string,
  itemName: string,
  captureDate: Date
): Promise<boolean> {
  const db = await getDb();
  if (!db) return false;

  const existing = await db
    .select({ id: evidenceRecords.id })
    .from(evidenceRecords)
    .where(
      and(
        eq(evidenceRecords.sourceUrl, sourceUrl),
        eq(evidenceRecords.itemName, itemName),
        sql`DATE(${evidenceRecords.captureDate}) = DATE(${captureDate})`
      )
    )
    .limit(1);

  return existing.length > 0;
}

// ─── Category Mapping ────────────────────────────────────────────

/** Map connector evidence categories to evidence_records table enum values */
const CATEGORY_MAP: Record<string, string> = {
  material_cost: "other",
  fitout_rate: "other",
  market_trend: "other",
  competitor_project: "other",
  floors: "floors",
  walls: "walls",
  ceilings: "ceilings",
  joinery: "joinery",
  lighting: "lighting",
  sanitary: "sanitary",
  kitchen: "kitchen",
  hardware: "hardware",
  ffe: "ffe",
  other: "other",
};

function mapCategory(category: string): string {
  return CATEGORY_MAP[category] || "other";
}

// ─── Record ID Generator ─────────────────────────────────────────

let recordCounter = 0;

function generateRecordId(): string {
  recordCounter++;
  const ts = Date.now().toString(36);
  const rand = Math.random().toString(36).substring(2, 6);
  return `MYR-PE-${ts}-${rand}`.toUpperCase();
}

// ─── Orchestrator ────────────────────────────────────────────────

export async function runIngestion(
  connectors: SourceConnector[],
  triggeredBy: "manual" | "scheduled" | "api" = "manual",
  actorId?: number
): Promise<IngestionRunReport> {
  const runId = `ING-${randomUUID().substring(0, 8)}`;
  const startedAt = new Date();

  const connectorResults: ConnectorResult[] = [];

  // V3-03: Load lastSuccessfulFetch from sourceRegistry for each connector
  try {
    const db = await getDb();
    if (db) {
      for (const connector of connectors) {
        const rows = await db.select({ lastSuccessfulFetch: sourceRegistry.lastSuccessfulFetch })
          .from(sourceRegistry)
          .where(eq(sourceRegistry.name, connector.sourceId))
          .limit(1);
        if (rows.length > 0 && rows[0].lastSuccessfulFetch) {
          connector.lastSuccessfulFetch = rows[0].lastSuccessfulFetch;
        }
      }
    }
  } catch (err) {
    console.warn("[Ingestion] Failed to load lastSuccessfulFetch:", err);
  }

  // Build tasks for parallel execution
  const tasks = connectors.map((connector) => async (): Promise<ConnectorResult> => {
    try {
      // Step 1: Fetch
      const raw = await connector.fetch();

      if (raw.error && raw.statusCode === 0) {
        // Total fetch failure (network error, timeout)
        return {
          sourceId: connector.sourceId,
          sourceName: connector.sourceName,
          status: "failed",
          evidenceExtracted: 0,
          evidenceCreated: 0,
          evidenceSkipped: 0,
          error: raw.error,
        };
      }

      if (raw.statusCode >= 400) {
        return {
          sourceId: connector.sourceId,
          sourceName: connector.sourceName,
          status: "failed",
          evidenceExtracted: 0,
          evidenceCreated: 0,
          evidenceSkipped: 0,
          error: raw.error || `HTTP ${raw.statusCode}`,
        };
      }

      // Step 2: Extract
      let extracted: ExtractedEvidence[];
      try {
        extracted = await connector.extract(raw);
      } catch (err) {
        return {
          sourceId: connector.sourceId,
          sourceName: connector.sourceName,
          status: "failed",
          evidenceExtracted: 0,
          evidenceCreated: 0,
          evidenceSkipped: 0,
          error: `Extract failed: ${err instanceof Error ? err.message : String(err)}`,
        };
      }

      // Validate extracted evidence
      const validExtracted = extracted.filter((e) => {
        const result = extractedEvidenceSchema.safeParse(e);
        return result.success;
      });

      let created = 0;
      let skipped = 0;

      // Step 3: Normalize and persist each evidence item
      for (const evidence of validExtracted) {
        try {
          // Normalize
          let normalized: NormalizedEvidenceInput;
          try {
            normalized = await connector.normalize(evidence);
          } catch (err) {
            // Safe fallback for malformed normalization
            normalized = {
              metric: evidence.title,
              value: null,
              unit: null,
              confidence: 0.20,
              grade: "C",
              summary: evidence.rawText.substring(0, 500),
              tags: [],
            };
          }

          // Validate normalized output
          const validationResult = normalizedEvidenceInputSchema.safeParse(normalized);
          if (!validationResult.success) {
            // Use safe fallback
            normalized = {
              metric: evidence.title || "Unknown metric",
              value: null,
              unit: null,
              confidence: 0.20,
              grade: "C",
              summary: evidence.rawText.substring(0, 500) || "Extraction failed",
              tags: [],
            };
          }

          // Duplicate detection
          const captureDate = evidence.publishedDate || raw.fetchedAt;
          const duplicate = await isDuplicate(
            evidence.sourceUrl,
            normalized.metric,
            captureDate
          );

          if (duplicate) {
            skipped++;
            continue;
          }

          // Persist to evidence_records
          const { id: newRecordId } = await createEvidenceRecord({
            recordId: generateRecordId(),
            sourceRegistryId: typeof connector.sourceId === 'number' ? connector.sourceId : (parseInt(connector.sourceId) || undefined),
            sourceUrl: evidence.sourceUrl,
            category: mapCategory(evidence.category) as any,
            itemName: normalized.metric,
            priceTypical: normalized.value?.toString() ?? null,
            unit: normalized.unit || "unit",
            currencyOriginal: "AED",
            captureDate: captureDate,
            reliabilityGrade: normalized.grade,
            confidenceScore: Math.round(normalized.confidence * 100),
            extractedSnippet: normalized.summary,
            publisher: connector.sourceName,
            title: evidence.title,
            tags: normalized.tags,
            notes: `Auto-ingested from ${connector.sourceName} via V2 ingestion engine`,
            runId: runId,
          });

          // Hand off to the intelligent change detector to log significant fluctuations
          const insertedRecord = await getEvidenceRecordById(newRecordId);
          if (insertedRecord) {
            await detectPriceChange(insertedRecord);
          }

          created++;
        } catch (err) {
          // Individual record failure — continue with next
          console.error(`[Ingestion] Record persist failed for ${connector.sourceId}:`, err);
        }
      }

      return {
        sourceId: connector.sourceId,
        sourceName: connector.sourceName,
        status: "success",
        evidenceExtracted: validExtracted.length,
        evidenceCreated: created,
        evidenceSkipped: skipped,
      };
    } catch (err) {
      // Catch-all for any unhandled errors in the connector pipeline
      return {
        sourceId: connector.sourceId,
        sourceName: connector.sourceName,
        status: "failed",
        evidenceExtracted: 0,
        evidenceCreated: 0,
        evidenceSkipped: 0,
        error: `Unhandled: ${err instanceof Error ? err.message : String(err)}`,
      };
    }
  });

  // Execute with concurrency limit
  const results = await runWithConcurrencyLimit(tasks, MAX_CONCURRENT);
  connectorResults.push(...results);

  // V3-02: Record connector health for each connector
  for (const result of connectorResults) {
    try {
      const healthStatus = result.status === "success"
        ? (result.evidenceCreated > 0 ? "success" : "partial")
        : "failed";

      let errorType: string | null = null;
      if (result.error) {
        if (result.error.includes("ENOTFOUND") || result.error.includes("DNS") || result.error.includes("resolve")) {
          errorType = "dns_failure";
        } else if (result.error.includes("timeout") || result.error.includes("ETIMEDOUT")) {
          errorType = "timeout";
        } else if (result.error.includes("HTTP")) {
          errorType = "http_error";
        } else if (result.error.includes("Extract") || result.error.includes("parse")) {
          errorType = "parse_error";
        } else if (result.error.includes("LLM") || result.error.includes("invokeLLM")) {
          errorType = "llm_error";
        } else {
          errorType = "unknown";
        }
      }

      await insertConnectorHealth({
        runId,
        sourceId: result.sourceId,
        sourceName: result.sourceName,
        status: healthStatus as any,
        httpStatusCode: null,
        responseTimeMs: null,
        recordsExtracted: result.evidenceExtracted,
        recordsInserted: result.evidenceCreated,
        duplicatesSkipped: result.evidenceSkipped,
        errorMessage: result.error || null,
        errorType,
      });
    } catch (err) {
      console.error(`[Ingestion] Failed to record health for ${result.sourceId}:`, err);
    }
  }

  // V3-03: Update lastSuccessfulFetch and DFE health metrics for all connectors
  try {
    const db = await getDb();
    if (db) {
      for (const result of connectorResults) {
        // Get current consecutive failures to increment
        const current = await db.select({ consecutiveFailures: sourceRegistry.consecutiveFailures })
          .from(sourceRegistry).where(eq(sourceRegistry.name, result.sourceId)).limit(1);

        const currentFailures = current.length > 0 ? current[0].consecutiveFailures : 0;
        const isSuccess = result.status === "success";
        const statusEnum = isSuccess ? (result.evidenceExtracted > 0 ? "success" : "partial") : "failed";

        const updates: any = {
          lastScrapedAt: new Date(),
          lastScrapedStatus: statusEnum,
          lastRecordCount: result.evidenceCreated,
          consecutiveFailures: isSuccess ? 0 : currentFailures + 1,
        };
        if (isSuccess) {
          updates.lastSuccessfulFetch = new Date();
        }

        await db.update(sourceRegistry)
          .set(updates)
          .where(eq(sourceRegistry.name, result.sourceId));
      }
    }
  } catch (err) {
    console.warn("[Ingestion] Failed to update sourceRegistry metrics:", err);
  }

  const completedAt = new Date();
  const durationMs = completedAt.getTime() - startedAt.getTime();

  // Aggregate results
  const succeeded = connectorResults.filter((r) => r.status === "success").length;
  const failed = connectorResults.filter((r) => r.status === "failed").length;
  const totalCreated = connectorResults.reduce((sum, r) => sum + r.evidenceCreated, 0);
  const totalSkipped = connectorResults.reduce((sum, r) => sum + r.evidenceSkipped, 0);
  const errors = connectorResults
    .filter((r) => r.status === "failed" && r.error)
    .map((r) => ({
      sourceId: r.sourceId,
      sourceName: r.sourceName,
      error: r.error!,
    }));

  // Persist ingestion run record
  try {
    const db = await getDb();
    if (db) {
      await db.insert(ingestionRuns).values({
        runId,
        trigger: triggeredBy,
        triggeredBy: actorId ?? null,
        status: failed === connectors.length ? "failed" : "completed",
        totalSources: connectors.length,
        sourcesSucceeded: succeeded,
        sourcesFailed: failed,
        recordsExtracted: connectorResults.reduce((sum, r) => sum + r.evidenceExtracted, 0),
        recordsInserted: totalCreated,
        duplicatesSkipped: totalSkipped,
        sourceBreakdown: connectorResults.map((r) => ({
          sourceId: r.sourceId,
          name: r.sourceName,
          status: r.status,
          extracted: r.evidenceExtracted,
          inserted: r.evidenceCreated,
          duplicates: r.evidenceSkipped,
          error: r.error || null,
        })),
        errorSummary: errors.length > 0 ? errors : null,
        startedAt,
        completedAt,
        durationMs,
      });
    }
  } catch (err) {
    console.error("[Ingestion] Failed to persist ingestion run:", err);
  }

  // Log to intelligence audit log
  try {
    await createIntelligenceAuditEntry({
      runType: "price_extraction",
      runId: runId,
      actor: actorId ?? null,
      inputSummary: {
        triggeredBy,
        connectorCount: connectors.length,
        connectorIds: connectors.map((c) => c.sourceId),
      },
      outputSummary: {
        sourcesAttempted: connectors.length,
        sourcesSucceeded: succeeded,
        sourcesFailed: failed,
        evidenceCreated: totalCreated,
        evidenceSkipped: totalSkipped,
      },
      sourcesProcessed: connectors.length,
      recordsExtracted: totalCreated,
      errors: failed,
      errorDetails: errors.length > 0 ? errors : null,
      startedAt: startedAt,
      completedAt: completedAt,
    });
  } catch (err) {
    console.error("[Ingestion] Failed to log audit entry:", err);
  }

  // V2-08: Auto-generate benchmark proposals after ingestion
  let proposalResult: { proposalsCreated: number } | null = null;
  if (totalCreated > 0) {
    try {
      proposalResult = await generateBenchmarkProposals({
        actorId,
        ingestionRunId: runId,
      });
      console.log(
        `[Ingestion] Post-run proposal generation: ${proposalResult.proposalsCreated} proposals created`
      );
    } catch (err) {
      console.error("[Ingestion] Post-run proposal generation failed:", err);
    }
  }

  // V3-05: Auto-generate trend snapshots after ingestion
  if (totalCreated > 0) {
    try {
      const db = await getDb();
      if (db) {
        // Get distinct category/geography combos from recent evidence
        const recentEvidence = await db.select().from(evidenceRecords)
          .orderBy(sql`${evidenceRecords.createdAt} DESC`)
          .limit(500);

        // Group by category
        const categoryGroups = new Map<string, DataPoint[]>();
        for (const record of recentEvidence) {
          const value = record.priceMin ? parseFloat(String(record.priceMin)) : null;
          if (value === null || isNaN(value)) continue;
          const date = record.captureDate || record.createdAt;
          if (!date) continue;
          const category = record.category || "other";
          const grade = (record.reliabilityGrade as "A" | "B" | "C") || "C";
          if (!categoryGroups.has(category)) categoryGroups.set(category, []);
          categoryGroups.get(category)!.push({
            date: new Date(date),
            value,
            grade,
            sourceId: record.sourceRegistryId ? String(record.sourceRegistryId) : "unknown",
            recordId: record.id,
          });
        }

        let trendsGenerated = 0;
        for (const [category, points] of Array.from(categoryGroups.entries())) {
          if (points.length < 2) continue;
          const trend = await detectTrends(category, category, "UAE", points, {
            generateNarrative: points.length >= 5,
          });
          await insertTrendSnapshot({
            metric: trend.metric,
            category: trend.category,
            geography: trend.geography,
            dataPointCount: trend.dataPointCount,
            gradeACount: trend.gradeACount,
            gradeBCount: trend.gradeBCount,
            gradeCCount: trend.gradeCCount,
            uniqueSources: trend.uniqueSources,
            dateRangeStart: trend.dateRange?.start || null,
            dateRangeEnd: trend.dateRange?.end || null,
            currentMA: trend.currentMA !== null ? String(trend.currentMA) : null,
            previousMA: trend.previousMA !== null ? String(trend.previousMA) : null,
            percentChange: trend.percentChange !== null ? String(trend.percentChange) : null,
            direction: trend.direction,
            anomalyCount: trend.anomalies.length,
            anomalyDetails: trend.anomalies.length > 0 ? trend.anomalies : null,
            confidence: trend.confidence,
            narrative: trend.narrative,
            movingAverages: trend.movingAverages.length > 0 ? trend.movingAverages : null,
            ingestionRunId: runId,
          });
          trendsGenerated++;
        }
        console.log(`[Ingestion] Post-run trend detection: ${trendsGenerated} trend snapshots created`);
      }
    } catch (err) {
      console.error("[Ingestion] Post-run trend detection failed:", err);
    }
  }

  // V6: Autonomous Alert Generation
  try {
    const alerts = await triggerAlertEngine();
    console.log(`[Ingestion] Post-run alert generation: ${alerts.length} new alerts created`);
  } catch (err) {
    console.error("[Ingestion] Post-run alert generation failed:", err);
  }

  const report: IngestionRunReport = {
    runId,
    startedAt,
    completedAt,
    durationMs,
    triggeredBy,
    sourcesAttempted: connectors.length,
    sourcesSucceeded: succeeded,
    sourcesFailed: failed,
    evidenceCreated: totalCreated,
    evidenceSkipped: totalSkipped,
    errors,
    perSource: connectorResults,
  };

  return report;
}

/**
 * Run a single connector by sourceId.
 */
export async function runSingleConnector(
  connector: SourceConnector,
  triggeredBy: "manual" | "scheduled" | "api" = "manual",
  actorId?: number
): Promise<IngestionRunReport> {
  return runIngestion([connector], triggeredBy, actorId);
}

/**
 * Run a connector for testing purposes only. Does not save to the database.
 * Returns the raw payload size and up to 5 extracted valid records.
 */
export async function testScrape(connector: SourceConnector) {
  const startedAt = new Date();

  const raw = await connector.fetch();
  if (raw.error) {
    return { success: false, error: raw.error, statusCode: raw.statusCode };
  }

  const extracted = await connector.extract(raw);
  const normalizedRecords = [];

  for (const evidence of extracted) {
    if (!extractedEvidenceSchema.safeParse(evidence).success) continue;
    try {
      const normalized = await connector.normalize(evidence);
      if (normalizedEvidenceInputSchema.safeParse(normalized).success) {
        normalizedRecords.push(normalized);
      }
    } catch { }
  }

  return {
    success: true,
    statusCode: raw.statusCode,
    rawPayloadSize: (raw.rawHtml?.length || 0) + JSON.stringify(raw.rawJson || {}).length,
    extractedCount: extracted.length,
    validNormalizedCount: normalizedRecords.length,
    previewRecords: normalizedRecords.slice(0, 5),
    durationMs: new Date().getTime() - startedAt.getTime()
  };
}
===
/**
 * MIYAR V2 — Ingestion Orchestrator
 *
 * Central orchestrator that manages connector execution, queuing,
 * and result persistence. Executes connectors in parallel (max 3
 * concurrent), handles failures gracefully, detects duplicates,
 * and logs all events to the audit log.
 */

import { randomUUID } from "crypto";
import type {
  SourceConnector,
  ExtractedEvidence,
  NormalizedEvidenceInput,
} from "./connector";
import {
  extractedEvidenceSchema,
  normalizedEvidenceInputSchema,
} from "./connector";
import {
  createEvidenceRecord,
  createIntelligenceAuditEntry,
  insertConnectorHealth,
  insertTrendSnapshot,
  getDb,
  getEvidenceRecordById
} from "../../db";
import { generateBenchmarkProposals } from "./proposal-generator";
import { triggerAlertEngine } from "../autonomous/alert-engine";
import { detectPriceChange } from "./change-detector";
import { detectTrends, type DataPoint } from "../analytics/trend-detection";
import { evidenceRecords, ingestionRuns, sourceRegistry } from "../../../drizzle/schema";
import { and, eq, sql } from "drizzle-orm";

// ─── Types ───────────────────────────────────────────────────────

export interface IngestionRunReport {
  runId: string;
  startedAt: Date;
  completedAt: Date;
  durationMs: number;
  triggeredBy: "manual" | "scheduled" | "api";
  sourcesAttempted: number;
  sourcesSucceeded: number;
  sourcesFailed: number;
  evidenceCreated: number;
  evidenceSkipped: number;
  errors: Array<{ sourceId: string; sourceName: string; error: string }>;
  perSource: Array<{
    sourceId: string;
    sourceName: string;
    status: "success" | "failed";
    evidenceExtracted: number;
    evidenceCreated: number;
    evidenceSkipped: number;
    error?: string;
  }>;
}

interface ConnectorResult {
  sourceId: string;
  sourceName: string;
  status: "success" | "failed";
  evidenceExtracted: number;
  evidenceCreated: number;
  evidenceSkipped: number;
  error?: string;
}

// ─── Concurrency Limiter ─────────────────────────────────────────

const MAX_CONCURRENT = 3;

async function runWithConcurrencyLimit<T>(
  tasks: Array<() => Promise<T>>,
  limit: number
): Promise<T[]> {
  const results: T[] = [];
  let index = 0;

  async function runNext(): Promise<void> {
    while (index < tasks.length) {
      const currentIndex = index++;
      results[currentIndex] = await tasks[currentIndex]();
    }
  }

  const workers = Array.from(
    { length: Math.min(limit, tasks.length) },
    () => runNext()
  );

  await Promise.all(workers);
  return results;
}

// ─── Duplicate Detection ─────────────────────────────────────────

/**
 * Check if an evidence record from the same source URL + item name
 * + capture date already exists. Uses sourceUrl + itemName + captureDate
 * as the composite uniqueness key.
 */
async function isDuplicate(
  sourceUrl: string,
  itemName: string,
  captureDate: Date
): Promise<boolean> {
  const db = await getDb();
  if (!db) return false;

  const existing = await db
    .select({ id: evidenceRecords.id })
    .from(evidenceRecords)
    .where(
      and(
        eq(evidenceRecords.sourceUrl, sourceUrl),
        eq(evidenceRecords.itemName, itemName),
        sql`DATE(${evidenceRecords.captureDate}) = DATE(${captureDate})`
      )
    )
    .limit(1);

  return existing.length > 0;
}

// ─── Category Mapping ────────────────────────────────────────────

/** Map connector evidence categories to evidence_records table enum values */
const CATEGORY_MAP: Record<string, string> = {
  material_cost: "floors",         // LLM now sets correct category per-item
  fitout_rate: "other",
  market_trend: "other",
  competitor_project: "other",
  floors: "floors",
  walls: "walls",
  ceilings: "ceilings",
  joinery: "joinery",
  lighting: "lighting",
  sanitary: "sanitary",
  kitchen: "kitchen",
  hardware: "hardware",
  ffe: "ffe",
  other: "other",
};

function mapCategory(category: string): string {
  return CATEGORY_MAP[category] || "other";
}

// ─── Record ID Generator ─────────────────────────────────────────

let recordCounter = 0;

function generateRecordId(): string {
  recordCounter++;
  const ts = Date.now().toString(36);
  const rand = Math.random().toString(36).substring(2, 6);
  return `MYR-PE-${ts}-${rand}`.toUpperCase();
}

// ─── Orchestrator ────────────────────────────────────────────────

export async function runIngestion(
  connectors: SourceConnector[],
  triggeredBy: "manual" | "scheduled" | "api" = "manual",
  actorId?: number
): Promise<IngestionRunReport> {
  const runId = `ING-${randomUUID().substring(0, 8)}`;
  const startedAt = new Date();

  const connectorResults: ConnectorResult[] = [];

  // V3-03: Load lastSuccessfulFetch from sourceRegistry for each connector
  try {
    const db = await getDb();
    if (db) {
      for (const connector of connectors) {
        const rows = await db.select({ lastSuccessfulFetch: sourceRegistry.lastSuccessfulFetch })
          .from(sourceRegistry)
          .where(eq(sourceRegistry.name, connector.sourceId))
          .limit(1);
        if (rows.length > 0 && rows[0].lastSuccessfulFetch) {
          connector.lastSuccessfulFetch = rows[0].lastSuccessfulFetch;
        }
      }
    }
  } catch (err) {
    console.warn("[Ingestion] Failed to load lastSuccessfulFetch:", err);
  }

  // Build tasks for parallel execution
  const tasks = connectors.map((connector) => async (): Promise<ConnectorResult> => {
    try {
      // Step 1: Fetch
      const raw = await connector.fetch();

      if (raw.error && raw.statusCode === 0) {
        // Total fetch failure (network error, timeout)
        return {
          sourceId: connector.sourceId,
          sourceName: connector.sourceName,
          status: "failed",
          evidenceExtracted: 0,
          evidenceCreated: 0,
          evidenceSkipped: 0,
          error: raw.error,
        };
      }

      if (raw.statusCode >= 400) {
        return {
          sourceId: connector.sourceId,
          sourceName: connector.sourceName,
          status: "failed",
          evidenceExtracted: 0,
          evidenceCreated: 0,
          evidenceSkipped: 0,
          error: raw.error || `HTTP ${raw.statusCode}`,
        };
      }

      // Step 2: Extract
      let extracted: ExtractedEvidence[];
      try {
        extracted = await connector.extract(raw);
      } catch (err) {
        return {
          sourceId: connector.sourceId,
          sourceName: connector.sourceName,
          status: "failed",
          evidenceExtracted: 0,
          evidenceCreated: 0,
          evidenceSkipped: 0,
          error: `Extract failed: ${err instanceof Error ? err.message : String(err)}`,
        };
      }

      // Validate extracted evidence
      const validExtracted = extracted.filter((e) => {
        const result = extractedEvidenceSchema.safeParse(e);
        return result.success;
      });

      let created = 0;
      let skipped = 0;

      // Step 3: Normalize and persist each evidence item
      for (const evidence of validExtracted) {
        try {
          // Normalize
          let normalized: NormalizedEvidenceInput;
          try {
            normalized = await connector.normalize(evidence);
          } catch (err) {
            // Safe fallback for malformed normalization
            normalized = {
              metric: evidence.title,
              value: null,
              unit: null,
              confidence: 0.20,
              grade: "C",
              summary: evidence.rawText.substring(0, 500),
              tags: [],
            };
          }

          // Validate normalized output
          const validationResult = normalizedEvidenceInputSchema.safeParse(normalized);
          if (!validationResult.success) {
            // Use safe fallback
            normalized = {
              metric: evidence.title || "Unknown metric",
              value: null,
              unit: null,
              confidence: 0.20,
              grade: "C",
              summary: evidence.rawText.substring(0, 500) || "Extraction failed",
              tags: [],
            };
          }

          // Duplicate detection
          const captureDate = evidence.publishedDate || raw.fetchedAt;
          const duplicate = await isDuplicate(
            evidence.sourceUrl,
            normalized.metric,
            captureDate
          );

          if (duplicate) {
            skipped++;
            continue;
          }

          // Persist to evidence_records
          // Map category: use LLM-provided category if valid, otherwise fallback
          const validCategories = ["floors","walls","ceilings","joinery","lighting","sanitary","kitchen","hardware","ffe","other"];
          const evidenceCategory = validCategories.includes(evidence.category)
            ? evidence.category
            : mapCategory(evidence.category);

          const { id: newRecordId } = await createEvidenceRecord({
            recordId: generateRecordId(),
            sourceRegistryId: typeof connector.sourceId === 'number' ? connector.sourceId : (parseInt(connector.sourceId) || undefined),
            sourceUrl: evidence.sourceUrl,
            category: evidenceCategory as any,
            itemName: normalized.metric,
            priceMin: normalized.value?.toString() ?? null,
            priceMax: normalized.valueMax?.toString() ?? normalized.value?.toString() ?? null,
            priceTypical: normalized.value?.toString() ?? null,
            unit: normalized.unit || "unit",
            currencyOriginal: "AED",
            captureDate: captureDate,
            reliabilityGrade: normalized.grade,
            confidenceScore: Math.round(normalized.confidence * 100),
            extractedSnippet: normalized.summary,
            publisher: connector.sourceName,
            title: evidence.title,
            tags: normalized.tags,
            notes: `Auto-ingested from ${connector.sourceName} via V2 ingestion engine`,
            runId: runId,
            // V7: Design Intelligence Fields
            finishLevel: (normalized.finishLevel as any) ?? null,
            designStyle: normalized.designStyle ?? null,
            brandsMentioned: normalized.brandsMentioned ?? null,
            materialSpec: normalized.materialSpec ?? null,
            intelligenceType: (normalized.intelligenceType as any) ?? "material_price",
          });

          // Hand off to the intelligent change detector to log significant fluctuations
          const insertedRecord = await getEvidenceRecordById(newRecordId);
          if (insertedRecord) {
            await detectPriceChange(insertedRecord);
          }

          created++;
        } catch (err) {
          // Individual record failure — continue with next
          console.error(`[Ingestion] Record persist failed for ${connector.sourceId}:`, err);
        }
      }

      return {
        sourceId: connector.sourceId,
        sourceName: connector.sourceName,
        status: "success",
        evidenceExtracted: validExtracted.length,
        evidenceCreated: created,
        evidenceSkipped: skipped,
      };
    } catch (err) {
      // Catch-all for any unhandled errors in the connector pipeline
      return {
        sourceId: connector.sourceId,
        sourceName: connector.sourceName,
        status: "failed",
        evidenceExtracted: 0,
        evidenceCreated: 0,
        evidenceSkipped: 0,
        error: `Unhandled: ${err instanceof Error ? err.message : String(err)}`,
      };
    }
  });

  // Execute with concurrency limit
  const results = await runWithConcurrencyLimit(tasks, MAX_CONCURRENT);
  connectorResults.push(...results);

  // V3-02: Record connector health for each connector
  for (const result of connectorResults) {
    try {
      const healthStatus = result.status === "success"
        ? (result.evidenceCreated > 0 ? "success" : "partial")
        : "failed";

      let errorType: string | null = null;
      if (result.error) {
        if (result.error.includes("ENOTFOUND") || result.error.includes("DNS") || result.error.includes("resolve")) {
          errorType = "dns_failure";
        } else if (result.error.includes("timeout") || result.error.includes("ETIMEDOUT")) {
          errorType = "timeout";
        } else if (result.error.includes("HTTP")) {
          errorType = "http_error";
        } else if (result.error.includes("Extract") || result.error.includes("parse")) {
          errorType = "parse_error";
        } else if (result.error.includes("LLM") || result.error.includes("invokeLLM")) {
          errorType = "llm_error";
        } else {
          errorType = "unknown";
        }
      }

      await insertConnectorHealth({
        runId,
        sourceId: result.sourceId,
        sourceName: result.sourceName,
        status: healthStatus as any,
        httpStatusCode: null,
        responseTimeMs: null,
        recordsExtracted: result.evidenceExtracted,
        recordsInserted: result.evidenceCreated,
        duplicatesSkipped: result.evidenceSkipped,
        errorMessage: result.error || null,
        errorType,
      });
    } catch (err) {
      console.error(`[Ingestion] Failed to record health for ${result.sourceId}:`, err);
    }
  }

  // V3-03: Update lastSuccessfulFetch and DFE health metrics for all connectors
  try {
    const db = await getDb();
    if (db) {
      for (const result of connectorResults) {
        // Get current consecutive failures to increment
        const current = await db.select({ consecutiveFailures: sourceRegistry.consecutiveFailures })
          .from(sourceRegistry).where(eq(sourceRegistry.name, result.sourceId)).limit(1);

        const currentFailures = current.length > 0 ? current[0].consecutiveFailures : 0;
        const isSuccess = result.status === "success";
        const statusEnum = isSuccess ? (result.evidenceExtracted > 0 ? "success" : "partial") : "failed";

        const updates: any = {
          lastScrapedAt: new Date(),
          lastScrapedStatus: statusEnum,
          lastRecordCount: result.evidenceCreated,
          consecutiveFailures: isSuccess ? 0 : currentFailures + 1,
        };
        if (isSuccess) {
          updates.lastSuccessfulFetch = new Date();
        }

        await db.update(sourceRegistry)
          .set(updates)
          .where(eq(sourceRegistry.name, result.sourceId));
      }
    }
  } catch (err) {
    console.warn("[Ingestion] Failed to update sourceRegistry metrics:", err);
  }

  const completedAt = new Date();
  const durationMs = completedAt.getTime() - startedAt.getTime();

  // Aggregate results
  const succeeded = connectorResults.filter((r) => r.status === "success").length;
  const failed = connectorResults.filter((r) => r.status === "failed").length;
  const totalCreated = connectorResults.reduce((sum, r) => sum + r.evidenceCreated, 0);
  const totalSkipped = connectorResults.reduce((sum, r) => sum + r.evidenceSkipped, 0);
  const errors = connectorResults
    .filter((r) => r.status === "failed" && r.error)
    .map((r) => ({
      sourceId: r.sourceId,
      sourceName: r.sourceName,
      error: r.error!,
    }));

  // Persist ingestion run record
  try {
    const db = await getDb();
    if (db) {
      await db.insert(ingestionRuns).values({
        runId,
        trigger: triggeredBy,
        triggeredBy: actorId ?? null,
        status: failed === connectors.length ? "failed" : "completed",
        totalSources: connectors.length,
        sourcesSucceeded: succeeded,
        sourcesFailed: failed,
        recordsExtracted: connectorResults.reduce((sum, r) => sum + r.evidenceExtracted, 0),
        recordsInserted: totalCreated,
        duplicatesSkipped: totalSkipped,
        sourceBreakdown: connectorResults.map((r) => ({
          sourceId: r.sourceId,
          name: r.sourceName,
          status: r.status,
          extracted: r.evidenceExtracted,
          inserted: r.evidenceCreated,
          duplicates: r.evidenceSkipped,
          error: r.error || null,
        })),
        errorSummary: errors.length > 0 ? errors : null,
        startedAt,
        completedAt,
        durationMs,
      });
    }
  } catch (err) {
    console.error("[Ingestion] Failed to persist ingestion run:", err);
  }

  // Log to intelligence audit log
  try {
    await createIntelligenceAuditEntry({
      runType: "price_extraction",
      runId: runId,
      actor: actorId ?? null,
      inputSummary: {
        triggeredBy,
        connectorCount: connectors.length,
        connectorIds: connectors.map((c) => c.sourceId),
      },
      outputSummary: {
        sourcesAttempted: connectors.length,
        sourcesSucceeded: succeeded,
        sourcesFailed: failed,
        evidenceCreated: totalCreated,
        evidenceSkipped: totalSkipped,
      },
      sourcesProcessed: connectors.length,
      recordsExtracted: totalCreated,
      errors: failed,
      errorDetails: errors.length > 0 ? errors : null,
      startedAt: startedAt,
      completedAt: completedAt,
    });
  } catch (err) {
    console.error("[Ingestion] Failed to log audit entry:", err);
  }

  // V2-08: Auto-generate benchmark proposals after ingestion
  let proposalResult: { proposalsCreated: number } | null = null;
  if (totalCreated > 0) {
    try {
      proposalResult = await generateBenchmarkProposals({
        actorId,
        ingestionRunId: runId,
      });
      console.log(
        `[Ingestion] Post-run proposal generation: ${proposalResult.proposalsCreated} proposals created`
      );
    } catch (err) {
      console.error("[Ingestion] Post-run proposal generation failed:", err);
    }
  }

  // V3-05: Auto-generate trend snapshots after ingestion
  if (totalCreated > 0) {
    try {
      const db = await getDb();
      if (db) {
        // Get distinct category/geography combos from recent evidence
        const recentEvidence = await db.select().from(evidenceRecords)
          .orderBy(sql`${evidenceRecords.createdAt} DESC`)
          .limit(500);

        // Group by category
        const categoryGroups = new Map<string, DataPoint[]>();
        for (const record of recentEvidence) {
          const value = record.priceMin ? parseFloat(String(record.priceMin)) : null;
          if (value === null || isNaN(value)) continue;
          const date = record.captureDate || record.createdAt;
          if (!date) continue;
          const category = record.category || "other";
          const grade = (record.reliabilityGrade as "A" | "B" | "C") || "C";
          if (!categoryGroups.has(category)) categoryGroups.set(category, []);
          categoryGroups.get(category)!.push({
            date: new Date(date),
            value,
            grade,
            sourceId: record.sourceRegistryId ? String(record.sourceRegistryId) : "unknown",
            recordId: record.id,
          });
        }

        let trendsGenerated = 0;
        for (const [category, points] of Array.from(categoryGroups.entries())) {
          if (points.length < 2) continue;
          const trend = await detectTrends(category, category, "UAE", points, {
            generateNarrative: points.length >= 5,
          });
          await insertTrendSnapshot({
            metric: trend.metric,
            category: trend.category,
            geography: trend.geography,
            dataPointCount: trend.dataPointCount,
            gradeACount: trend.gradeACount,
            gradeBCount: trend.gradeBCount,
            gradeCCount: trend.gradeCCount,
            uniqueSources: trend.uniqueSources,
            dateRangeStart: trend.dateRange?.start || null,
            dateRangeEnd: trend.dateRange?.end || null,
            currentMA: trend.currentMA !== null ? String(trend.currentMA) : null,
            previousMA: trend.previousMA !== null ? String(trend.previousMA) : null,
            percentChange: trend.percentChange !== null ? String(trend.percentChange) : null,
            direction: trend.direction,
            anomalyCount: trend.anomalies.length,
            anomalyDetails: trend.anomalies.length > 0 ? trend.anomalies : null,
            confidence: trend.confidence,
            narrative: trend.narrative,
            movingAverages: trend.movingAverages.length > 0 ? trend.movingAverages : null,
            ingestionRunId: runId,
          });
          trendsGenerated++;
        }
        console.log(`[Ingestion] Post-run trend detection: ${trendsGenerated} trend snapshots created`);
      }
    } catch (err) {
      console.error("[Ingestion] Post-run trend detection failed:", err);
    }
  }

  // V6: Autonomous Alert Generation
  try {
    const alerts = await triggerAlertEngine();
    console.log(`[Ingestion] Post-run alert generation: ${alerts.length} new alerts created`);
  } catch (err) {
    console.error("[Ingestion] Post-run alert generation failed:", err);
  }

  // V7: Auto-sync Evidence → Materials Library
  if (totalCreated > 0) {
    try {
      const { syncEvidenceToMaterials } = await import("./evidence-to-materials");
      const materialSync = await syncEvidenceToMaterials(runId);
      console.log(
        `[Ingestion] Post-run materials sync: ${materialSync.created} created, ${materialSync.updated} updated, ${materialSync.skipped} skipped`
      );
    } catch (err) {
      console.error("[Ingestion] Post-run materials sync failed:", err);
    }
  }

  const report: IngestionRunReport = {
    runId,
    startedAt,
    completedAt,
    durationMs,
    triggeredBy,
    sourcesAttempted: connectors.length,
    sourcesSucceeded: succeeded,
    sourcesFailed: failed,
    evidenceCreated: totalCreated,
    evidenceSkipped: totalSkipped,
    errors,
    perSource: connectorResults,
  };

  return report;
}

/**
 * Run a single connector by sourceId.
 */
export async function runSingleConnector(
  connector: SourceConnector,
  triggeredBy: "manual" | "scheduled" | "api" = "manual",
  actorId?: number
): Promise<IngestionRunReport> {
  return runIngestion([connector], triggeredBy, actorId);
}

/**
 * Run a connector for testing purposes only. Does not save to the database.
 * Returns the raw payload size and up to 5 extracted valid records.
 */
export async function testScrape(connector: SourceConnector) {
  const startedAt = new Date();

  const raw = await connector.fetch();
  if (raw.error) {
    return { success: false, error: raw.error, statusCode: raw.statusCode };
  }

  const extracted = await connector.extract(raw);
  const normalizedRecords = [];

  for (const evidence of extracted) {
    if (!extractedEvidenceSchema.safeParse(evidence).success) continue;
    try {
      const normalized = await connector.normalize(evidence);
      if (normalizedEvidenceInputSchema.safeParse(normalized).success) {
        normalizedRecords.push(normalized);
      }
    } catch { }
  }

  return {
    success: true,
    statusCode: raw.statusCode,
    rawPayloadSize: (raw.rawHtml?.length || 0) + JSON.stringify(raw.rawJson || {}).length,
    extractedCount: extracted.length,
    validNormalizedCount: normalizedRecords.length,
    previewRecords: normalizedRecords.slice(0, 5),
    durationMs: new Date().getTime() - startedAt.getTime()
  };
}
```

### 4. Extended Interface

```diff:connector.ts
/**
 * MIYAR V2 — Source Connector Interface & Base Class
 *
 * All 12 UAE source connectors implement SourceConnector.
 * BaseSourceConnector provides shared fetch logic with timeout,
 * retry (exponential backoff, max 3 attempts), and error capture.
 *
 * LLM is permitted ONLY for:
 *   - Extracting structured data from unstructured HTML
 *   - Normalizing free-text into metric/value/unit/summary
 *   - Generating evidence summary narrative
 *
 * LLM must NOT be used for: scoring, weighting, ranking,
 * deciding confidence levels, or any numerical computation.
 */

import { z } from "zod";
// @ts-ignore
import robotsParser from "robots-parser";

// ─── Constants & Resilience Data ─────────────────────────────────

const USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15",
];

const CAPTCHA_INDICATORS = ["cf-browser-verification", "g-recaptcha", "px-captcha", "Please verify you are a human"];
const PAYWALL_INDICATORS = ["subscribe to read", "premium content", "paywall"];

function getRandomUserAgent() {
  return USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
}

const robotsCache = new Map<string, ReturnType<typeof robotsParser>>();

async function checkRobotsTxt(targetUrl: string, userAgent: string): Promise<boolean> {
  try {
    const urlObj = new URL(targetUrl);
    const origin = urlObj.origin;
    let robots = robotsCache.get(origin);

    if (!robots) {
      const robotsUrl = `${origin}/robots.txt`;
      const res = await globalThis.fetch(robotsUrl, { headers: { "User-Agent": userAgent } });
      if (res.ok) {
        const text = await res.text();
        robots = robotsParser(robotsUrl, text);
      } else {
        robots = robotsParser(robotsUrl, "");
      }
      robotsCache.set(origin, robots);
    }

    return robots.isAllowed(targetUrl, userAgent) !== false;
  } catch (err) {
    return true; // fail open
  }
}

// ─── Types ───────────────────────────────────────────────────────

export interface SourceConnector {
  sourceId: string;
  sourceName: string;
  sourceUrl: string;
  /** Optional: set by orchestrator before fetch to enable incremental ingestion */
  lastSuccessfulFetch?: Date;
  /** Optional: artificial delay applied before the specific request fires */
  requestDelayMs?: number;
  fetch(): Promise<RawSourcePayload>;
  extract(raw: RawSourcePayload): Promise<ExtractedEvidence[]>;
  normalize(evidence: ExtractedEvidence): Promise<NormalizedEvidenceInput>;
}

export interface RawSourcePayload {
  url: string;
  fetchedAt: Date;
  rawHtml?: string;
  rawJson?: object;
  statusCode: number;
  error?: string;
}

export interface ExtractedEvidence {
  title: string;
  rawText: string;
  publishedDate?: Date;
  category: string; // "material_cost" | "fitout_rate" | "market_trend" | "competitor_project"
  geography: string; // "Dubai" | "Abu Dhabi" | "UAE"
  sourceUrl: string;
}

export interface NormalizedEvidenceInput {
  metric: string;
  value: number | null;
  unit: string | null;
  confidence: number; // 0.0 – 1.0
  grade: "A" | "B" | "C";
  summary: string;
  tags: string[];
}

// ─── Zod Schemas (runtime validation) ────────────────────────────

export const rawSourcePayloadSchema = z.object({
  url: z.string().url(),
  fetchedAt: z.date(),
  rawHtml: z.string().optional(),
  rawJson: z.record(z.string(), z.unknown()).optional(),
  statusCode: z.number().int(),
  error: z.string().optional(),
});

export const extractedEvidenceSchema = z.object({
  title: z.string().min(1),
  rawText: z.string().min(1),
  publishedDate: z.date().optional(),
  category: z.enum(["material_cost", "fitout_rate", "market_trend", "competitor_project"]),
  geography: z.string().min(1),
  sourceUrl: z.string().url(),
});

export const normalizedEvidenceInputSchema = z.object({
  metric: z.string().min(1),
  value: z.number().nullable(),
  unit: z.string().nullable(),
  confidence: z.number().min(0).max(1),
  grade: z.enum(["A", "B", "C"]),
  summary: z.string().min(1),
  tags: z.array(z.string()),
});

// ─── Deterministic Grade Assignment ──────────────────────────────

/** Grade A sources: verified government, international research, official industry bodies */
const GRADE_A_SOURCE_IDS = new Set([
  "emaar-properties",
  "damac-properties",
  "nakheel-properties",
  "rics-market-reports",
  "jll-mena-research",
  "dubai-statistics-center",
  "dubai-pulse-materials",
  "scad-abu-dhabi",
  "dld-transactions",
  "aldar-properties",
  "cbre-uae-research",
  "knight-frank-uae",
  "savills-me-research",
]);

/** Grade B sources: established trade suppliers with published price lists */
const GRADE_B_SOURCE_IDS = new Set([
  "rak-ceramics-uae",
  "porcelanosa-uae",
  "hafele-uae",
  "gems-building-materials",
  "dragon-mart-dubai",
  "property-monitor-dubai",
]);

/** Grade C sources: interior design / fit-out firms with project-based pricing */
const GRADE_C_SOURCE_IDS = new Set([
  "dera-interiors",
]);

export function assignGrade(sourceId: string): "A" | "B" | "C" {
  if (GRADE_A_SOURCE_IDS.has(sourceId)) return "A";
  if (GRADE_B_SOURCE_IDS.has(sourceId)) return "B";
  if (GRADE_C_SOURCE_IDS.has(sourceId)) return "C";
  return "C"; // default to lowest grade for unknown sources
}

// ─── Deterministic Confidence Rules ──────────────────────────────

const BASE_CONFIDENCE: Record<string, number> = { A: 0.85, B: 0.70, C: 0.55 };
const RECENCY_BONUS = 0.10;       // publishedDate within 90 days
const STALENESS_PENALTY = -0.15;  // publishedDate > 365 days or missing
const CONFIDENCE_CAP = 1.0;
const CONFIDENCE_FLOOR = 0.20;

export function computeConfidence(
  grade: "A" | "B" | "C",
  publishedDate: Date | undefined,
  fetchedAt: Date
): number {
  let confidence = BASE_CONFIDENCE[grade];

  if (!publishedDate) {
    confidence += STALENESS_PENALTY;
  } else {
    const daysSincePublished = Math.floor(
      (fetchedAt.getTime() - publishedDate.getTime()) / (1000 * 60 * 60 * 24)
    );
    if (daysSincePublished <= 90) {
      confidence += RECENCY_BONUS;
    } else if (daysSincePublished > 365) {
      confidence += STALENESS_PENALTY;
    }
  }

  return Math.min(CONFIDENCE_CAP, Math.max(CONFIDENCE_FLOOR, confidence));
}

// ─── Base Source Connector ────────────────────────────────────────

const FETCH_TIMEOUT_MS = 15_000;
const MAX_RETRIES = 3;
const BASE_BACKOFF_MS = 1_000;

export abstract class BaseSourceConnector implements SourceConnector {
  abstract sourceId: string;
  abstract sourceName: string;
  abstract sourceUrl: string;
  /** Set by orchestrator before fetch to enable incremental ingestion */
  lastSuccessfulFetch?: Date;
  requestDelayMs?: number;

  /**
   * Shared fetch with timeout (15s) and exponential backoff retry (max 3 attempts).
   * Returns RawSourcePayload with error field populated on failure.
   */
  async fetch(): Promise<RawSourcePayload> {
    let lastError: string | undefined;
    const userAgent = getRandomUserAgent();

    const isAllowed = await checkRobotsTxt(this.sourceUrl, userAgent);
    if (!isAllowed) {
      return {
        url: this.sourceUrl,
        fetchedAt: new Date(),
        statusCode: 403,
        error: "Blocked by origin robots.txt",
      };
    }

    if (this.requestDelayMs && this.requestDelayMs > 0) {
      await new Promise(r => setTimeout(r, this.requestDelayMs));
    }

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);

        const response = await globalThis.fetch(this.sourceUrl, {
          signal: controller.signal,
          headers: {
            "User-Agent": userAgent,
            "Accept": "text/html,application/json,application/xml;q=0.9,*/*;q=0.8",
          },
        });

        clearTimeout(timeout);

        const contentType = response.headers.get("content-type") || "";
        let rawHtml: string | undefined;
        let rawJson: object | undefined;

        if (contentType.includes("application/json")) {
          rawJson = await response.json() as object;
        } else {
          rawHtml = await response.text();

          if (CAPTCHA_INDICATORS.some(ind => rawHtml!.includes(ind))) {
            throw new Error("CAPTCHA challenge detected on page");
          }
          if (PAYWALL_INDICATORS.some(ind => rawHtml!.toLowerCase().includes(ind))) {
            throw new Error("Paywall detected on page content");
          }

          // Try to parse as JSON if it looks like JSON
          if (rawHtml.trim().startsWith("{") || rawHtml.trim().startsWith("[")) {
            try {
              rawJson = JSON.parse(rawHtml);
            } catch {
              // Keep as HTML
            }
          }
        }

        return {
          url: this.sourceUrl,
          fetchedAt: new Date(),
          rawHtml,
          rawJson,
          statusCode: response.status,
          error: response.ok ? undefined : `HTTP ${response.status} ${response.statusText}`,
        };
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : String(err);
        lastError = errorMsg;

        if (attempt < MAX_RETRIES) {
          const backoffMs = BASE_BACKOFF_MS * Math.pow(2, attempt - 1);
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
        }
      }
    }

    return {
      url: this.sourceUrl,
      fetchedAt: new Date(),
      statusCode: 0,
      error: `Failed after ${MAX_RETRIES} attempts: ${lastError}`,
    };
  }

  abstract extract(raw: RawSourcePayload): Promise<ExtractedEvidence[]>;
  abstract normalize(evidence: ExtractedEvidence): Promise<NormalizedEvidenceInput>;
}
===
/**
 * MIYAR V2 — Source Connector Interface & Base Class
 *
 * All UAE source connectors implement SourceConnector.
 * BaseSourceConnector provides shared fetch logic with timeout,
 * retry (exponential backoff, max 3 attempts), and error capture.
 *
 * Supports Firecrawl for JavaScript-rendered pages when
 * FIRECRAWL_API_KEY is set in environment.
 *
 * LLM is permitted ONLY for:
 *   - Extracting structured data from unstructured HTML
 *   - Normalizing free-text into metric/value/unit/summary
 *   - Generating evidence summary narrative
 *
 * LLM must NOT be used for: scoring, weighting, ranking,
 * deciding confidence levels, or any numerical computation.
 */

import { z } from "zod";
// @ts-ignore
import robotsParser from "robots-parser";

// ─── Constants & Resilience Data ─────────────────────────────────

const USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15",
];

const CAPTCHA_INDICATORS = ["cf-browser-verification", "g-recaptcha", "px-captcha", "Please verify you are a human"];
const PAYWALL_INDICATORS = ["subscribe to read", "premium content", "paywall"];

function getRandomUserAgent() {
  return USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
}

const robotsCache = new Map<string, ReturnType<typeof robotsParser>>();

async function checkRobotsTxt(targetUrl: string, userAgent: string): Promise<boolean> {
  try {
    const urlObj = new URL(targetUrl);
    const origin = urlObj.origin;
    let robots = robotsCache.get(origin);

    if (!robots) {
      const robotsUrl = `${origin}/robots.txt`;
      const res = await globalThis.fetch(robotsUrl, { headers: { "User-Agent": userAgent } });
      if (res.ok) {
        const text = await res.text();
        robots = robotsParser(robotsUrl, text);
      } else {
        robots = robotsParser(robotsUrl, "");
      }
      robotsCache.set(origin, robots);
    }

    return robots.isAllowed(targetUrl, userAgent) !== false;
  } catch (err) {
    return true; // fail open
  }
}

// ─── Firecrawl Client (lazy-loaded) ─────────────────────────────

let _firecrawlClient: any = null;
let _firecrawlInitPromise: Promise<any> | null = null;

async function getFirecrawlClient(): Promise<any | null> {
  const apiKey = process.env.FIRECRAWL_API_KEY;
  if (!apiKey) return null;

  if (!_firecrawlClient && !_firecrawlInitPromise) {
    _firecrawlInitPromise = (async () => {
      try {
        const mod = await import("@mendable/firecrawl-js");
        const FirecrawlApp = mod.default;
        _firecrawlClient = new FirecrawlApp({ apiKey });
      } catch (err) {
        console.warn("[Connector] Firecrawl SDK not available, falling back to basic fetch");
      }
      return _firecrawlClient;
    })();
  }

  if (_firecrawlInitPromise) await _firecrawlInitPromise;
  return _firecrawlClient;
}

/** Check if Firecrawl is available */
export function isFirecrawlAvailable(): boolean {
  return !!process.env.FIRECRAWL_API_KEY;
}

// ─── Types ───────────────────────────────────────────────────────

export interface SourceConnector {
  sourceId: string;
  sourceName: string;
  sourceUrl: string;
  /** Optional: set by orchestrator before fetch to enable incremental ingestion */
  lastSuccessfulFetch?: Date;
  /** Optional: artificial delay applied before the specific request fires */
  requestDelayMs?: number;
  fetch(): Promise<RawSourcePayload>;
  extract(raw: RawSourcePayload): Promise<ExtractedEvidence[]>;
  normalize(evidence: ExtractedEvidence): Promise<NormalizedEvidenceInput>;
}

export interface RawSourcePayload {
  url: string;
  fetchedAt: Date;
  rawHtml?: string;
  rawJson?: object;
  /** Markdown content from Firecrawl (cleaner than HTML for LLM) */
  markdown?: string;
  statusCode: number;
  error?: string;
}

export interface ExtractedEvidence {
  title: string;
  rawText: string;
  publishedDate?: Date;
  category: string;
  geography: string;
  sourceUrl: string;
}

export interface NormalizedEvidenceInput {
  metric: string;
  value: number | null;
  valueMax?: number | null;
  unit: string | null;
  confidence: number;
  grade: "A" | "B" | "C";
  summary: string;
  tags: string[];
  brand?: string | null;
  // V7: Design Intelligence Fields
  finishLevel?: string | null;
  designStyle?: string | null;
  brandsMentioned?: string[] | null;
  materialSpec?: string | null;
  intelligenceType?: string;
}

// ─── Zod Schemas (runtime validation) ────────────────────────────

export const rawSourcePayloadSchema = z.object({
  url: z.string().url(),
  fetchedAt: z.date(),
  rawHtml: z.string().optional(),
  rawJson: z.record(z.string(), z.unknown()).optional(),
  markdown: z.string().optional(),
  statusCode: z.number().int(),
  error: z.string().optional(),
});

export const extractedEvidenceSchema = z.object({
  title: z.string().min(1),
  rawText: z.string().min(1),
  publishedDate: z.date().optional(),
  category: z.enum(["material_cost", "fitout_rate", "market_trend", "competitor_project"]),
  geography: z.string().min(1),
  sourceUrl: z.string().url(),
});

export const normalizedEvidenceInputSchema = z.object({
  metric: z.string().min(1),
  value: z.number().nullable(),
  unit: z.string().nullable(),
  confidence: z.number().min(0).max(1),
  grade: z.enum(["A", "B", "C"]),
  summary: z.string().min(1),
  tags: z.array(z.string()),
});

// ─── Deterministic Grade Assignment ──────────────────────────────

const GRADE_A_SOURCE_IDS = new Set([
  "emaar-properties", "damac-properties", "nakheel-properties",
  "rics-market-reports", "jll-mena-research", "dubai-statistics-center",
  "dubai-pulse-materials", "scad-abu-dhabi", "dld-transactions",
  "aldar-properties", "cbre-uae-research", "knight-frank-uae", "savills-me-research",
]);

const GRADE_B_SOURCE_IDS = new Set([
  "rak-ceramics-uae", "porcelanosa-uae", "hafele-uae",
  "gems-building-materials", "dragon-mart-dubai", "property-monitor-dubai",
]);

const GRADE_C_SOURCE_IDS = new Set(["dera-interiors"]);

export function assignGrade(sourceId: string): "A" | "B" | "C" {
  if (GRADE_A_SOURCE_IDS.has(sourceId)) return "A";
  if (GRADE_B_SOURCE_IDS.has(sourceId)) return "B";
  if (GRADE_C_SOURCE_IDS.has(sourceId)) return "C";
  return "C";
}

// ─── Deterministic Confidence Rules ──────────────────────────────

const BASE_CONFIDENCE: Record<string, number> = { A: 0.85, B: 0.70, C: 0.55 };
const RECENCY_BONUS = 0.10;
const STALENESS_PENALTY = -0.15;
const CONFIDENCE_CAP = 1.0;
const CONFIDENCE_FLOOR = 0.20;

export function computeConfidence(
  grade: "A" | "B" | "C",
  publishedDate: Date | undefined,
  fetchedAt: Date
): number {
  let confidence = BASE_CONFIDENCE[grade];

  if (!publishedDate) {
    confidence += STALENESS_PENALTY;
  } else {
    const daysSincePublished = Math.floor(
      (fetchedAt.getTime() - publishedDate.getTime()) / (1000 * 60 * 60 * 24)
    );
    if (daysSincePublished <= 90) {
      confidence += RECENCY_BONUS;
    } else if (daysSincePublished > 365) {
      confidence += STALENESS_PENALTY;
    }
  }

  return Math.min(CONFIDENCE_CAP, Math.max(CONFIDENCE_FLOOR, confidence));
}

// ─── Base Source Connector ────────────────────────────────────────

const FETCH_TIMEOUT_MS = 15_000;
const MAX_RETRIES = 3;
const BASE_BACKOFF_MS = 1_000;

export abstract class BaseSourceConnector implements SourceConnector {
  abstract sourceId: string;
  abstract sourceName: string;
  abstract sourceUrl: string;
  lastSuccessfulFetch?: Date;
  requestDelayMs?: number;

  /**
   * Fetch using Firecrawl's headless browser API.
   * Renders JavaScript, bypasses bot protection, returns clean markdown.
   */
  async fetchWithFirecrawl(url?: string): Promise<RawSourcePayload> {
    const targetUrl = url || this.sourceUrl;
    const client = await getFirecrawlClient();

    if (!client) {
      return this.fetchBasic(targetUrl);
    }

    try {
      console.log(`[Connector] 🔥 Firecrawl scraping: ${targetUrl}`);
      // v4 SDK: scrape() returns Document directly (no success wrapper)
      const doc: any = await client.scrape(targetUrl, {
        formats: ["markdown", "html"],
      });

      const markdown = doc?.markdown || "";
      const html = doc?.html || "";

      if (markdown.length < 50 && html.length < 50) {
        console.warn(`[Connector] Firecrawl returned too little content for ${targetUrl}, falling back`);
        return this.fetchBasic(targetUrl);
      }

      console.log(`[Connector] 🔥 Firecrawl success: ${targetUrl} (${markdown.length} chars md, ${html.length} chars html)`);

      return {
        url: targetUrl,
        fetchedAt: new Date(),
        rawHtml: html,
        markdown,
        statusCode: doc?.metadata?.statusCode || 200,
      };
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : String(err);
      console.warn(`[Connector] Firecrawl error for ${targetUrl}: ${errorMsg}, falling back`);
      return this.fetchBasic(targetUrl);
    }
  }

  /**
   * Basic HTTP fetch — used as fallback when Firecrawl is unavailable.
   */
  async fetchBasic(url?: string): Promise<RawSourcePayload> {
    const targetUrl = url || this.sourceUrl;
    let lastError: string | undefined;
    const userAgent = getRandomUserAgent();

    const isAllowed = await checkRobotsTxt(targetUrl, userAgent);
    if (!isAllowed) {
      return { url: targetUrl, fetchedAt: new Date(), statusCode: 403, error: "Blocked by origin robots.txt" };
    }

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);

        const response = await globalThis.fetch(targetUrl, {
          signal: controller.signal,
          headers: {
            "User-Agent": userAgent,
            "Accept": "text/html,application/json,application/xml;q=0.9,*/*;q=0.8",
          },
        });

        clearTimeout(timeout);

        const contentType = response.headers.get("content-type") || "";
        let rawHtml: string | undefined;
        let rawJson: object | undefined;

        if (contentType.includes("application/json")) {
          rawJson = await response.json() as object;
        } else {
          rawHtml = await response.text();

          if (CAPTCHA_INDICATORS.some(ind => rawHtml!.includes(ind))) {
            throw new Error("CAPTCHA challenge detected on page");
          }
          if (PAYWALL_INDICATORS.some(ind => rawHtml!.toLowerCase().includes(ind))) {
            throw new Error("Paywall detected on page content");
          }

          if (rawHtml.trim().startsWith("{") || rawHtml.trim().startsWith("[")) {
            try { rawJson = JSON.parse(rawHtml); } catch { /* Keep as HTML */ }
          }
        }

        return {
          url: targetUrl,
          fetchedAt: new Date(),
          rawHtml,
          rawJson,
          statusCode: response.status,
          error: response.ok ? undefined : `HTTP ${response.status} ${response.statusText}`,
        };
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : String(err);
        lastError = errorMsg;

        if (attempt < MAX_RETRIES) {
          const backoffMs = BASE_BACKOFF_MS * Math.pow(2, attempt - 1);
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
        }
      }
    }

    return {
      url: targetUrl,
      fetchedAt: new Date(),
      statusCode: 0,
      error: `Failed after ${MAX_RETRIES} attempts: ${lastError}`,
    };
  }

  /**
   * Main fetch method. Uses Firecrawl when available, falls back to basic HTTP.
   */
  async fetch(): Promise<RawSourcePayload> {
    if (this.requestDelayMs && this.requestDelayMs > 0) {
      await new Promise(r => setTimeout(r, this.requestDelayMs));
    }

    if (isFirecrawlAvailable()) {
      return this.fetchWithFirecrawl();
    }

    return this.fetchBasic();
  }

  abstract extract(raw: RawSourcePayload): Promise<ExtractedEvidence[]>;
  abstract normalize(evidence: ExtractedEvidence): Promise<NormalizedEvidenceInput>;
}
```

## Verification

| Check | Result |
|---|---|
| Schema migration | ✅ Applied (5 new columns) |
| Build | ✅ Compiles cleanly |
| `intelligenceType` field | ✅ Set to `material_price` for existing records |
| Test re-scrape (Emaar) | ⚠️ 0 items — homepage is navigation only, no finish detail |
| Test re-scrape (RAK Ceramics) | ⚠️ 0 items — homepage is catalog navigation, no product prices |
| Git push | ✅ Deployed to Vercel |

> [!NOTE]
> The 0-item results are **expected behavior** — the prompts correctly return empty arrays when pages don't contain relevant data. Full scrape with Firecrawl multi-page crawling (depth 1+) will reach product detail pages where the actual data lives.

## Next Steps
- Run [run-full-scrape.ts](file:///Users/amrosaleh/Maiyar/miyar-v2/server/engines/ingestion/seeds/run-full-scrape.ts) to re-scrape all 86 sources with the new prompts
- This will populate `finishLevel`, `designStyle`, `brandsMentioned` for developer sources
- Supplier sources should now capture actual AED prices (not null)
